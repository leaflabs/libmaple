   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 18, 4
  12              		.thumb
  13              		.file	"stm32f10x_usart.c"
  21              	.Ltext0:
  22              		.align	2
  23              		.global	USART_StructInit
  24              		.thumb
  25              		.thumb_func
  27              	USART_StructInit:
  28              	.LFB25:
  29              		.file 1 "stm32lib/src/stm32f10x_usart.c"
   1:stm32lib/src/stm32f10x_usart.c **** /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
   2:stm32lib/src/stm32f10x_usart.c **** * File Name          : stm32f10x_usart.c
   3:stm32lib/src/stm32f10x_usart.c **** * Author             : MCD Application Team
   4:stm32lib/src/stm32f10x_usart.c **** * Version            : V2.0.2
   5:stm32lib/src/stm32f10x_usart.c **** * Date               : 07/11/2008
   6:stm32lib/src/stm32f10x_usart.c **** * Description        : This file provides all the USART firmware functions.
   7:stm32lib/src/stm32f10x_usart.c **** ********************************************************************************
   8:stm32lib/src/stm32f10x_usart.c **** * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
   9:stm32lib/src/stm32f10x_usart.c **** * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
  10:stm32lib/src/stm32f10x_usart.c **** * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
  11:stm32lib/src/stm32f10x_usart.c **** * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
  12:stm32lib/src/stm32f10x_usart.c **** * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
  13:stm32lib/src/stm32f10x_usart.c **** * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  14:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
  15:stm32lib/src/stm32f10x_usart.c **** 
  16:stm32lib/src/stm32f10x_usart.c **** /* Includes ------------------------------------------------------------------*/
  17:stm32lib/src/stm32f10x_usart.c **** #include "stm32f10x_usart.h"
  18:stm32lib/src/stm32f10x_usart.c **** #include "stm32f10x_rcc.h"
  19:stm32lib/src/stm32f10x_usart.c **** 
  20:stm32lib/src/stm32f10x_usart.c **** /* Private typedef -----------------------------------------------------------*/
  21:stm32lib/src/stm32f10x_usart.c **** /* Private define ------------------------------------------------------------*/
  22:stm32lib/src/stm32f10x_usart.c **** /* USART UE Mask */
  23:stm32lib/src/stm32f10x_usart.c **** #define CR1_UE_Set                ((u16)0x2000)  /* USART Enable Mask */
  24:stm32lib/src/stm32f10x_usart.c **** #define CR1_UE_Reset              ((u16)0xDFFF)  /* USART Disable Mask */
  25:stm32lib/src/stm32f10x_usart.c **** 
  26:stm32lib/src/stm32f10x_usart.c **** /* USART WakeUp Method  */
  27:stm32lib/src/stm32f10x_usart.c **** #define CR1_WAKE_Mask             ((u16)0xF7FF)  /* USART WakeUp Method Mask */
  28:stm32lib/src/stm32f10x_usart.c **** 
  29:stm32lib/src/stm32f10x_usart.c **** /* USART RWU Mask */
  30:stm32lib/src/stm32f10x_usart.c **** #define CR1_RWU_Set               ((u16)0x0002)  /* USART mute mode Enable Mask */
  31:stm32lib/src/stm32f10x_usart.c **** #define CR1_RWU_Reset             ((u16)0xFFFD)  /* USART mute mode Enable Mask */
  32:stm32lib/src/stm32f10x_usart.c **** 
  33:stm32lib/src/stm32f10x_usart.c **** #define CR1_SBK_Set               ((u16)0x0001)  /* USART Break Character send Mask */
  34:stm32lib/src/stm32f10x_usart.c **** 
  35:stm32lib/src/stm32f10x_usart.c **** #define CR1_CLEAR_Mask            ((u16)0xE9F3)  /* USART CR1 Mask */
  36:stm32lib/src/stm32f10x_usart.c **** 
  37:stm32lib/src/stm32f10x_usart.c **** #define CR2_Address_Mask          ((u16)0xFFF0)  /* USART address Mask */
  38:stm32lib/src/stm32f10x_usart.c **** 
  39:stm32lib/src/stm32f10x_usart.c **** /* USART LIN Mask */
  40:stm32lib/src/stm32f10x_usart.c **** #define CR2_LINEN_Set              ((u16)0x4000)  /* USART LIN Enable Mask */
  41:stm32lib/src/stm32f10x_usart.c **** #define CR2_LINEN_Reset            ((u16)0xBFFF)  /* USART LIN Disable Mask */
  42:stm32lib/src/stm32f10x_usart.c **** 
  43:stm32lib/src/stm32f10x_usart.c **** /* USART LIN Break detection */
  44:stm32lib/src/stm32f10x_usart.c **** #define CR2_LBDL_Mask             ((u16)0xFFDF)  /* USART LIN Break detection Mask */
  45:stm32lib/src/stm32f10x_usart.c **** 
  46:stm32lib/src/stm32f10x_usart.c **** #define CR2_STOP_CLEAR_Mask       ((u16)0xCFFF)  /* USART CR2 STOP Bits Mask */
  47:stm32lib/src/stm32f10x_usart.c **** #define CR2_CLOCK_CLEAR_Mask      ((u16)0xF0FF)  /* USART CR2 Clock Mask */
  48:stm32lib/src/stm32f10x_usart.c **** 
  49:stm32lib/src/stm32f10x_usart.c **** /* USART SC Mask */
  50:stm32lib/src/stm32f10x_usart.c **** #define CR3_SCEN_Set              ((u16)0x0020)  /* USART SC Enable Mask */
  51:stm32lib/src/stm32f10x_usart.c **** #define CR3_SCEN_Reset            ((u16)0xFFDF)  /* USART SC Disable Mask */
  52:stm32lib/src/stm32f10x_usart.c **** 
  53:stm32lib/src/stm32f10x_usart.c **** /* USART SC NACK Mask */
  54:stm32lib/src/stm32f10x_usart.c **** #define CR3_NACK_Set              ((u16)0x0010)  /* USART SC NACK Enable Mask */
  55:stm32lib/src/stm32f10x_usart.c **** #define CR3_NACK_Reset            ((u16)0xFFEF)  /* USART SC NACK Disable Mask */
  56:stm32lib/src/stm32f10x_usart.c **** 
  57:stm32lib/src/stm32f10x_usart.c **** /* USART Half-Duplex Mask */
  58:stm32lib/src/stm32f10x_usart.c **** #define CR3_HDSEL_Set             ((u16)0x0008)  /* USART Half-Duplex Enable Mask */
  59:stm32lib/src/stm32f10x_usart.c **** #define CR3_HDSEL_Reset           ((u16)0xFFF7)  /* USART Half-Duplex Disable Mask */
  60:stm32lib/src/stm32f10x_usart.c **** 
  61:stm32lib/src/stm32f10x_usart.c **** /* USART IrDA Mask */
  62:stm32lib/src/stm32f10x_usart.c **** #define CR3_IRLP_Mask             ((u16)0xFFFB)  /* USART IrDA LowPower mode Mask */
  63:stm32lib/src/stm32f10x_usart.c **** 
  64:stm32lib/src/stm32f10x_usart.c **** #define CR3_CLEAR_Mask            ((u16)0xFCFF)  /* USART CR3 Mask */
  65:stm32lib/src/stm32f10x_usart.c **** 
  66:stm32lib/src/stm32f10x_usart.c **** /* USART IrDA Mask */
  67:stm32lib/src/stm32f10x_usart.c **** #define CR3_IREN_Set              ((u16)0x0002)  /* USART IrDA Enable Mask */
  68:stm32lib/src/stm32f10x_usart.c **** #define CR3_IREN_Reset            ((u16)0xFFFD)  /* USART IrDA Disable Mask */
  69:stm32lib/src/stm32f10x_usart.c **** 
  70:stm32lib/src/stm32f10x_usart.c **** #define GTPR_LSB_Mask             ((u16)0x00FF)  /* Guard Time Register LSB Mask */
  71:stm32lib/src/stm32f10x_usart.c **** #define GTPR_MSB_Mask             ((u16)0xFF00)  /* Guard Time Register MSB Mask */
  72:stm32lib/src/stm32f10x_usart.c **** 
  73:stm32lib/src/stm32f10x_usart.c **** #define IT_Mask                   ((u16)0x001F)  /* USART Interrupt Mask */
  74:stm32lib/src/stm32f10x_usart.c **** 
  75:stm32lib/src/stm32f10x_usart.c **** /* Private macro -------------------------------------------------------------*/
  76:stm32lib/src/stm32f10x_usart.c **** /* Private variables ---------------------------------------------------------*/
  77:stm32lib/src/stm32f10x_usart.c **** /* Private function prototypes -----------------------------------------------*/
  78:stm32lib/src/stm32f10x_usart.c **** /* Private functions ---------------------------------------------------------*/
  79:stm32lib/src/stm32f10x_usart.c **** 
  80:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
  81:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_DeInit
  82:stm32lib/src/stm32f10x_usart.c **** * Description    : Deinitializes the USARTx peripheral registers to their
  83:stm32lib/src/stm32f10x_usart.c **** *                  default reset values.
  84:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
  85:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
  86:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
  87:stm32lib/src/stm32f10x_usart.c **** * Output         : None
  88:stm32lib/src/stm32f10x_usart.c **** * Return         : None
  89:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
  90:stm32lib/src/stm32f10x_usart.c **** void USART_DeInit(USART_TypeDef* USARTx)
  91:stm32lib/src/stm32f10x_usart.c **** {
  92:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
  93:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
  94:stm32lib/src/stm32f10x_usart.c **** 
  95:stm32lib/src/stm32f10x_usart.c ****   switch (*(u32*)&USARTx)
  96:stm32lib/src/stm32f10x_usart.c ****   {
  97:stm32lib/src/stm32f10x_usart.c ****     case USART1_BASE:
  98:stm32lib/src/stm32f10x_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
  99:stm32lib/src/stm32f10x_usart.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
 100:stm32lib/src/stm32f10x_usart.c ****       break;
 101:stm32lib/src/stm32f10x_usart.c **** 
 102:stm32lib/src/stm32f10x_usart.c ****     case USART2_BASE:
 103:stm32lib/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
 104:stm32lib/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
 105:stm32lib/src/stm32f10x_usart.c ****       break;
 106:stm32lib/src/stm32f10x_usart.c **** 
 107:stm32lib/src/stm32f10x_usart.c ****     case USART3_BASE:
 108:stm32lib/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
 109:stm32lib/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
 110:stm32lib/src/stm32f10x_usart.c ****       break;
 111:stm32lib/src/stm32f10x_usart.c ****     
 112:stm32lib/src/stm32f10x_usart.c ****     case UART4_BASE:
 113:stm32lib/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
 114:stm32lib/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
 115:stm32lib/src/stm32f10x_usart.c ****       break;
 116:stm32lib/src/stm32f10x_usart.c ****     
 117:stm32lib/src/stm32f10x_usart.c ****     case UART5_BASE:
 118:stm32lib/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
 119:stm32lib/src/stm32f10x_usart.c ****       RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
 120:stm32lib/src/stm32f10x_usart.c ****       break;            
 121:stm32lib/src/stm32f10x_usart.c **** 
 122:stm32lib/src/stm32f10x_usart.c ****     default:
 123:stm32lib/src/stm32f10x_usart.c ****       break;
 124:stm32lib/src/stm32f10x_usart.c ****   }
 125:stm32lib/src/stm32f10x_usart.c **** }
 126:stm32lib/src/stm32f10x_usart.c **** 
 127:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 128:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_Init
 129:stm32lib/src/stm32f10x_usart.c **** * Description    : Initializes the USARTx peripheral according to the specified
 130:stm32lib/src/stm32f10x_usart.c **** *                  parameters in the USART_InitStruct .
 131:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 132:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 133:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 134:stm32lib/src/stm32f10x_usart.c **** *                  - USART_InitStruct: pointer to a USART_InitTypeDef structure
 135:stm32lib/src/stm32f10x_usart.c **** *                    that contains the configuration information for the
 136:stm32lib/src/stm32f10x_usart.c **** *                    specified USART peripheral.
 137:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 138:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 139:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 140:stm32lib/src/stm32f10x_usart.c **** void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
 141:stm32lib/src/stm32f10x_usart.c **** {
 142:stm32lib/src/stm32f10x_usart.c ****   u32 tmpreg = 0x00, apbclock = 0x00;
 143:stm32lib/src/stm32f10x_usart.c ****   u32 integerdivider = 0x00;
 144:stm32lib/src/stm32f10x_usart.c ****   u32 fractionaldivider = 0x00;
 145:stm32lib/src/stm32f10x_usart.c ****   u32 usartxbase = 0;
 146:stm32lib/src/stm32f10x_usart.c ****   RCC_ClocksTypeDef RCC_ClocksStatus;
 147:stm32lib/src/stm32f10x_usart.c **** 
 148:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 149:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 150:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
 151:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
 152:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
 153:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
 154:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
 155:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
 156:stm32lib/src/stm32f10x_usart.c ****   /* The hardware flow control is available only for USART1, USART2 and USART3 */          
 157:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_PERIPH_HFC(USARTx, USART_InitStruct->USART_HardwareFlowControl));
 158:stm32lib/src/stm32f10x_usart.c ****   
 159:stm32lib/src/stm32f10x_usart.c ****   usartxbase = (*(u32*)&USARTx);
 160:stm32lib/src/stm32f10x_usart.c **** 
 161:stm32lib/src/stm32f10x_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 162:stm32lib/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR2;
 163:stm32lib/src/stm32f10x_usart.c ****   /* Clear STOP[13:12] bits */
 164:stm32lib/src/stm32f10x_usart.c ****   tmpreg &= CR2_STOP_CLEAR_Mask;
 165:stm32lib/src/stm32f10x_usart.c **** 
 166:stm32lib/src/stm32f10x_usart.c ****   /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
 167:stm32lib/src/stm32f10x_usart.c ****   /* Set STOP[13:12] bits according to USART_StopBits value */
 168:stm32lib/src/stm32f10x_usart.c ****   tmpreg |= (u32)USART_InitStruct->USART_StopBits;
 169:stm32lib/src/stm32f10x_usart.c ****   
 170:stm32lib/src/stm32f10x_usart.c ****   /* Write to USART CR2 */
 171:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR2 = (u16)tmpreg;
 172:stm32lib/src/stm32f10x_usart.c **** 
 173:stm32lib/src/stm32f10x_usart.c **** /*---------------------------- USART CR1 Configuration -----------------------*/
 174:stm32lib/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR1;
 175:stm32lib/src/stm32f10x_usart.c ****   /* Clear M, PCE, PS, TE and RE bits */
 176:stm32lib/src/stm32f10x_usart.c ****   tmpreg &= CR1_CLEAR_Mask;
 177:stm32lib/src/stm32f10x_usart.c **** 
 178:stm32lib/src/stm32f10x_usart.c ****   /* Configure the USART Word Length, Parity and mode ----------------------- */
 179:stm32lib/src/stm32f10x_usart.c ****   /* Set the M bits according to USART_WordLength value */
 180:stm32lib/src/stm32f10x_usart.c ****   /* Set PCE and PS bits according to USART_Parity value */
 181:stm32lib/src/stm32f10x_usart.c ****   /* Set TE and RE bits according to USART_Mode value */
 182:stm32lib/src/stm32f10x_usart.c ****   tmpreg |= (u32)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
 183:stm32lib/src/stm32f10x_usart.c ****             USART_InitStruct->USART_Mode;
 184:stm32lib/src/stm32f10x_usart.c **** 
 185:stm32lib/src/stm32f10x_usart.c ****   /* Write to USART CR1 */
 186:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR1 = (u16)tmpreg;
 187:stm32lib/src/stm32f10x_usart.c **** 
 188:stm32lib/src/stm32f10x_usart.c **** /*---------------------------- USART CR3 Configuration -----------------------*/  
 189:stm32lib/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR3;
 190:stm32lib/src/stm32f10x_usart.c ****   /* Clear CTSE and RTSE bits */
 191:stm32lib/src/stm32f10x_usart.c ****   tmpreg &= CR3_CLEAR_Mask;
 192:stm32lib/src/stm32f10x_usart.c **** 
 193:stm32lib/src/stm32f10x_usart.c ****   /* Configure the USART HFC -------------------------------------------------*/
 194:stm32lib/src/stm32f10x_usart.c ****   /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
 195:stm32lib/src/stm32f10x_usart.c ****   tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
 196:stm32lib/src/stm32f10x_usart.c **** 
 197:stm32lib/src/stm32f10x_usart.c ****   /* Write to USART CR3 */
 198:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR3 = (u16)tmpreg;
 199:stm32lib/src/stm32f10x_usart.c **** 
 200:stm32lib/src/stm32f10x_usart.c **** /*---------------------------- USART BRR Configuration -----------------------*/
 201:stm32lib/src/stm32f10x_usart.c ****   /* Configure the USART Baud Rate -------------------------------------------*/
 202:stm32lib/src/stm32f10x_usart.c ****   RCC_GetClocksFreq(&RCC_ClocksStatus);
 203:stm32lib/src/stm32f10x_usart.c ****   if (usartxbase == USART1_BASE)
 204:stm32lib/src/stm32f10x_usart.c ****   {
 205:stm32lib/src/stm32f10x_usart.c ****     apbclock = RCC_ClocksStatus.PCLK2_Frequency;
 206:stm32lib/src/stm32f10x_usart.c ****   }
 207:stm32lib/src/stm32f10x_usart.c ****   else
 208:stm32lib/src/stm32f10x_usart.c ****   {
 209:stm32lib/src/stm32f10x_usart.c ****     apbclock = RCC_ClocksStatus.PCLK1_Frequency;
 210:stm32lib/src/stm32f10x_usart.c ****   }
 211:stm32lib/src/stm32f10x_usart.c **** 
 212:stm32lib/src/stm32f10x_usart.c ****   /* Determine the integer part */
 213:stm32lib/src/stm32f10x_usart.c ****   integerdivider = ((0x19 * apbclock) / (0x04 * (USART_InitStruct->USART_BaudRate)));
 214:stm32lib/src/stm32f10x_usart.c ****   tmpreg = (integerdivider / 0x64) << 0x04;
 215:stm32lib/src/stm32f10x_usart.c **** 
 216:stm32lib/src/stm32f10x_usart.c ****   /* Determine the fractional part */
 217:stm32lib/src/stm32f10x_usart.c ****   fractionaldivider = integerdivider - (0x64 * (tmpreg >> 0x04));
 218:stm32lib/src/stm32f10x_usart.c ****   tmpreg |= ((((fractionaldivider * 0x10) + 0x32) / 0x64)) & ((u8)0x0F);
 219:stm32lib/src/stm32f10x_usart.c **** 
 220:stm32lib/src/stm32f10x_usart.c ****   /* Write to USART BRR */
 221:stm32lib/src/stm32f10x_usart.c ****   USARTx->BRR = (u16)tmpreg;
 222:stm32lib/src/stm32f10x_usart.c **** }
 223:stm32lib/src/stm32f10x_usart.c **** 
 224:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 225:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_StructInit
 226:stm32lib/src/stm32f10x_usart.c **** * Description    : Fills each USART_InitStruct member with its default value.
 227:stm32lib/src/stm32f10x_usart.c **** * Input          : - USART_InitStruct: pointer to a USART_InitTypeDef structure
 228:stm32lib/src/stm32f10x_usart.c **** *                    which will be initialized.
 229:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 230:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 231:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 232:stm32lib/src/stm32f10x_usart.c **** void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
 233:stm32lib/src/stm32f10x_usart.c **** {
  30              		.loc 1 233 0
  31              		@ args = 0, pretend = 0, frame = 0
  32              		@ frame_needed = 0, uses_anonymous_args = 0
  33              		@ link register save eliminated.
  34              	.LVL0:
 234:stm32lib/src/stm32f10x_usart.c ****   /* USART_InitStruct members default value */
 235:stm32lib/src/stm32f10x_usart.c ****   USART_InitStruct->USART_BaudRate = 9600;
  35              		.loc 1 235 0
  36 0000 4FF41653 		mov	r3, #9600
  37 0004 0360     		str	r3, [r0, #0]
 236:stm32lib/src/stm32f10x_usart.c ****   USART_InitStruct->USART_WordLength = USART_WordLength_8b;
 237:stm32lib/src/stm32f10x_usart.c ****   USART_InitStruct->USART_StopBits = USART_StopBits_1;
 238:stm32lib/src/stm32f10x_usart.c ****   USART_InitStruct->USART_Parity = USART_Parity_No ;
 239:stm32lib/src/stm32f10x_usart.c ****   USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
  38              		.loc 1 239 0
  39 0006 4FF00C02 		mov	r2, #12	@ movhi
  40              		.loc 1 236 0
  41 000a A3F51653 		sub	r3, r3, #9600
  42 000e 8380     		strh	r3, [r0, #4]	@ movhi
  43              		.loc 1 237 0
  44 0010 C380     		strh	r3, [r0, #6]	@ movhi
  45              		.loc 1 238 0
  46 0012 0381     		strh	r3, [r0, #8]	@ movhi
  47              		.loc 1 239 0
  48 0014 4281     		strh	r2, [r0, #10]	@ movhi
 240:stm32lib/src/stm32f10x_usart.c ****   USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
  49              		.loc 1 240 0
  50 0016 8381     		strh	r3, [r0, #12]	@ movhi
 241:stm32lib/src/stm32f10x_usart.c **** }
  51              		.loc 1 241 0
  52 0018 7047     		bx	lr
  53              	.LFE25:
  55 001a 00BF     		.align	2
  56              		.global	USART_ClockInit
  57              		.thumb
  58              		.thumb_func
  60              	USART_ClockInit:
  61              	.LFB26:
 242:stm32lib/src/stm32f10x_usart.c **** 
 243:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 244:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_ClockInit
 245:stm32lib/src/stm32f10x_usart.c **** * Description    : Initializes the USARTx peripheral Clock according to the 
 246:stm32lib/src/stm32f10x_usart.c **** *                  specified parameters in the USART_ClockInitStruct .
 247:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: where x can be 1, 2, 3 to select the USART peripheral.
 248:stm32lib/src/stm32f10x_usart.c **** *                    Note: The Smart Card mode is not available for UART4 and UART5.
 249:stm32lib/src/stm32f10x_usart.c **** *                  - USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 250:stm32lib/src/stm32f10x_usart.c **** *                    structure that contains the configuration information for 
 251:stm32lib/src/stm32f10x_usart.c **** *                    the specified USART peripheral.
 252:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 253:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 254:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 255:stm32lib/src/stm32f10x_usart.c **** void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
 256:stm32lib/src/stm32f10x_usart.c **** {
  62              		.loc 1 256 0
  63              		@ args = 0, pretend = 0, frame = 0
  64              		@ frame_needed = 0, uses_anonymous_args = 0
  65              	.LVL1:
 257:stm32lib/src/stm32f10x_usart.c ****   u32 tmpreg = 0x00;
 258:stm32lib/src/stm32f10x_usart.c **** 
 259:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 260:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 261:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
 262:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
 263:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
 264:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));              
 265:stm32lib/src/stm32f10x_usart.c ****   
 266:stm32lib/src/stm32f10x_usart.c **** /*---------------------------- USART CR2 Configuration -----------------------*/
 267:stm32lib/src/stm32f10x_usart.c ****   tmpreg = USARTx->CR2;
 268:stm32lib/src/stm32f10x_usart.c ****   /* Clear CLKEN, CPOL, CPHA and LBCL bits */
 269:stm32lib/src/stm32f10x_usart.c ****   tmpreg &= CR2_CLOCK_CLEAR_Mask;
 270:stm32lib/src/stm32f10x_usart.c **** 
 271:stm32lib/src/stm32f10x_usart.c ****   /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
 272:stm32lib/src/stm32f10x_usart.c ****   /* Set CLKEN bit according to USART_Clock value */
 273:stm32lib/src/stm32f10x_usart.c ****   /* Set CPOL bit according to USART_CPOL value */
 274:stm32lib/src/stm32f10x_usart.c ****   /* Set CPHA bit according to USART_CPHA value */
 275:stm32lib/src/stm32f10x_usart.c ****   /* Set LBCL bit according to USART_LastBit value */
 276:stm32lib/src/stm32f10x_usart.c ****   tmpreg |= (u32)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
 277:stm32lib/src/stm32f10x_usart.c ****                  USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
 278:stm32lib/src/stm32f10x_usart.c **** 
 279:stm32lib/src/stm32f10x_usart.c ****   /* Write to USART CR2 */
 280:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR2 = (u16)tmpreg;
  66              		.loc 1 280 0
  67 001c 4B88     		ldrh	r3, [r1, #2]
  68              		.loc 1 256 0
  69 001e 10B5     		push	{r4, lr}
  70              	.LCFI0:
  71              		.loc 1 280 0
  72 0020 0C88     		ldrh	r4, [r1, #0]
  73              		.loc 1 267 0
  74 0022 028A     		ldrh	r2, [r0, #16]
  75              		.loc 1 280 0
  76 0024 2343     		orrs	r3, r3, r4
  77 0026 8C88     		ldrh	r4, [r1, #4]
  78 0028 C988     		ldrh	r1, [r1, #6]
  79              	.LVL2:
  80              		.loc 1 269 0
  81 002a 22F47062 		bic	r2, r2, #3840
  82              	.LVL3:
  83              		.loc 1 280 0
  84 002e 2343     		orrs	r3, r3, r4
  85              		.loc 1 269 0
  86 0030 1204     		lsls	r2, r2, #16
  87              		.loc 1 280 0
  88 0032 0B43     		orrs	r3, r3, r1
  89              		.loc 1 269 0
  90 0034 120C     		lsrs	r2, r2, #16
  91              		.loc 1 280 0
  92 0036 9BB2     		uxth	r3, r3
  93 0038 1343     		orrs	r3, r3, r2
  94 003a 0382     		strh	r3, [r0, #16]	@ movhi
 281:stm32lib/src/stm32f10x_usart.c **** }
  95              		.loc 1 281 0
  96 003c 10BD     		pop	{r4, pc}
  97              	.LFE26:
  99 003e 00BF     		.align	2
 100              		.global	USART_ClockStructInit
 101              		.thumb
 102              		.thumb_func
 104              	USART_ClockStructInit:
 105              	.LFB27:
 282:stm32lib/src/stm32f10x_usart.c **** 
 283:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 284:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_ClockStructInit
 285:stm32lib/src/stm32f10x_usart.c **** * Description    : Fills each USART_ClockInitStruct member with its default value.
 286:stm32lib/src/stm32f10x_usart.c **** * Input          : - USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef
 287:stm32lib/src/stm32f10x_usart.c **** *                    structure which will be initialized.
 288:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 289:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 290:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 291:stm32lib/src/stm32f10x_usart.c **** void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
 292:stm32lib/src/stm32f10x_usart.c **** {
 106              		.loc 1 292 0
 107              		@ args = 0, pretend = 0, frame = 0
 108              		@ frame_needed = 0, uses_anonymous_args = 0
 109              		@ link register save eliminated.
 110              	.LVL4:
 293:stm32lib/src/stm32f10x_usart.c ****   /* USART_ClockInitStruct members default value */
 294:stm32lib/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
 111              		.loc 1 294 0
 112 0040 0023     		movs	r3, #0
 113 0042 0380     		strh	r3, [r0, #0]	@ movhi
 295:stm32lib/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
 114              		.loc 1 295 0
 115 0044 4380     		strh	r3, [r0, #2]	@ movhi
 296:stm32lib/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
 116              		.loc 1 296 0
 117 0046 8380     		strh	r3, [r0, #4]	@ movhi
 297:stm32lib/src/stm32f10x_usart.c ****   USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
 118              		.loc 1 297 0
 119 0048 C380     		strh	r3, [r0, #6]	@ movhi
 298:stm32lib/src/stm32f10x_usart.c **** }
 120              		.loc 1 298 0
 121 004a 7047     		bx	lr
 122              	.LFE27:
 124              		.align	2
 125              		.global	USART_Cmd
 126              		.thumb
 127              		.thumb_func
 129              	USART_Cmd:
 130              	.LFB28:
 299:stm32lib/src/stm32f10x_usart.c **** 
 300:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 301:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_Cmd
 302:stm32lib/src/stm32f10x_usart.c **** * Description    : Enables or disables the specified USART peripheral.
 303:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 304:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 305:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 306:stm32lib/src/stm32f10x_usart.c **** *                : - NewState: new state of the USARTx peripheral.
 307:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be: ENABLE or DISABLE.
 308:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 309:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 310:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 311:stm32lib/src/stm32f10x_usart.c **** void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
 312:stm32lib/src/stm32f10x_usart.c **** {
 131              		.loc 1 312 0
 132              		@ args = 0, pretend = 0, frame = 0
 133              		@ frame_needed = 0, uses_anonymous_args = 0
 134              		@ link register save eliminated.
 135              	.LVL5:
 313:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 314:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 315:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 316:stm32lib/src/stm32f10x_usart.c ****   
 317:stm32lib/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 136              		.loc 1 317 0
 137 004c 21B1     		cbz	r1, .L8
 318:stm32lib/src/stm32f10x_usart.c ****   {
 319:stm32lib/src/stm32f10x_usart.c ****     /* Enable the selected USART by setting the UE bit in the CR1 register */
 320:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR1 |= CR1_UE_Set;
 138              		.loc 1 320 0
 139 004e 8389     		ldrh	r3, [r0, #12]
 140 0050 9BB2     		uxth	r3, r3
 141 0052 43F40053 		orr	r3, r3, #8192
 142 0056 04E0     		b	.L11
 143              	.L8:
 321:stm32lib/src/stm32f10x_usart.c ****   }
 322:stm32lib/src/stm32f10x_usart.c ****   else
 323:stm32lib/src/stm32f10x_usart.c ****   {
 324:stm32lib/src/stm32f10x_usart.c ****     /* Disable the selected USART by clearing the UE bit in the CR1 register */
 325:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR1 &= CR1_UE_Reset;
 144              		.loc 1 325 0
 145 0058 8389     		ldrh	r3, [r0, #12]
 146 005a 23F40053 		bic	r3, r3, #8192
 147 005e 1B04     		lsls	r3, r3, #16
 148 0060 1B0C     		lsrs	r3, r3, #16
 149              	.L11:
 150 0062 8381     		strh	r3, [r0, #12]	@ movhi
 326:stm32lib/src/stm32f10x_usart.c ****   }
 327:stm32lib/src/stm32f10x_usart.c **** }
 151              		.loc 1 327 0
 152 0064 7047     		bx	lr
 153              	.LFE28:
 155 0066 00BF     		.align	2
 156              		.global	USART_ITConfig
 157              		.thumb
 158              		.thumb_func
 160              	USART_ITConfig:
 161              	.LFB29:
 328:stm32lib/src/stm32f10x_usart.c **** 
 329:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 330:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_ITConfig
 331:stm32lib/src/stm32f10x_usart.c **** * Description    : Enables or disables the specified USART interrupts.
 332:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 333:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 334:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 335:stm32lib/src/stm32f10x_usart.c **** *                  - USART_IT: specifies the USART interrupt sources to be
 336:stm32lib/src/stm32f10x_usart.c **** *                    enabled or disabled.
 337:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 338:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_CTS:  CTS change interrupt (not available for
 339:stm32lib/src/stm32f10x_usart.c **** *                                        UART4 and UART5)
 340:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_LBD:  LIN Break detection interrupt
 341:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_TXE:  Tansmit Data Register empty interrupt
 342:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_TC:   Transmission complete interrupt
 343:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_RXNE: Receive Data register not empty 
 344:stm32lib/src/stm32f10x_usart.c **** *                                        interrupt
 345:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_IDLE: Idle line detection interrupt
 346:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_PE:   Parity Error interrupt
 347:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_ERR:  Error interrupt(Frame error, noise
 348:stm32lib/src/stm32f10x_usart.c **** *                                        error, overrun error)
 349:stm32lib/src/stm32f10x_usart.c **** *                  - NewState: new state of the specified USARTx interrupts.
 350:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be: ENABLE or DISABLE.
 351:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 352:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 353:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 354:stm32lib/src/stm32f10x_usart.c **** void USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState)
 355:stm32lib/src/stm32f10x_usart.c **** {
 162              		.loc 1 355 0
 163              		@ args = 0, pretend = 0, frame = 8
 164              		@ frame_needed = 0, uses_anonymous_args = 0
 165              		@ link register save eliminated.
 166              	.LVL6:
 356:stm32lib/src/stm32f10x_usart.c ****   u32 usartreg = 0x00, itpos = 0x00, itmask = 0x00;
 357:stm32lib/src/stm32f10x_usart.c ****   u32 usartxbase = 0x00;
 358:stm32lib/src/stm32f10x_usart.c **** 
 359:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 360:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 361:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_CONFIG_IT(USART_IT));
 362:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UAR
 363:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 364:stm32lib/src/stm32f10x_usart.c **** 
 365:stm32lib/src/stm32f10x_usart.c ****   usartxbase = (*(u32*)&(USARTx));
 366:stm32lib/src/stm32f10x_usart.c **** 
 367:stm32lib/src/stm32f10x_usart.c ****   /* Get the USART register index */
 368:stm32lib/src/stm32f10x_usart.c ****   usartreg = (((u8)USART_IT) >> 0x05);
 167              		.loc 1 368 0
 168 0068 C1F3421C 		ubfx	ip, r1, #5, #3
 169              	.LVL7:
 369:stm32lib/src/stm32f10x_usart.c **** 
 370:stm32lib/src/stm32f10x_usart.c ****   /* Get the interrupt position */
 371:stm32lib/src/stm32f10x_usart.c ****   itpos = USART_IT & IT_Mask;
 372:stm32lib/src/stm32f10x_usart.c **** 
 373:stm32lib/src/stm32f10x_usart.c ****   itmask = (((u32)0x01) << itpos);
 170              		.loc 1 373 0
 171 006c 0123     		movs	r3, #1
 172 006e 01F01F01 		and	r1, r1, #31
 173              	.LVL8:
 174              		.loc 1 355 0
 175 0072 82B0     		sub	sp, sp, #8
 176              	.LCFI1:
 177              		.loc 1 373 0
 178 0074 13FA01F1 		lsls	r1, r3, r1
 179              	.LVL9:
 374:stm32lib/src/stm32f10x_usart.c ****     
 375:stm32lib/src/stm32f10x_usart.c ****   if (usartreg == 0x01) /* The IT is in CR1 register */
 180              		.loc 1 375 0
 181 0078 9C45     		cmp	ip, r3
 182              		.loc 1 355 0
 183 007a 0190     		str	r0, [sp, #4]
 184              		.loc 1 375 0
 185 007c 01D1     		bne	.L13
 186              	.LVL10:
 376:stm32lib/src/stm32f10x_usart.c ****   {
 377:stm32lib/src/stm32f10x_usart.c ****     usartxbase += 0x0C;
 187              		.loc 1 377 0
 188 007e 0C30     		adds	r0, r0, #12
 189              	.LVL11:
 190 0080 05E0     		b	.L14
 191              	.LVL12:
 192              	.L13:
 378:stm32lib/src/stm32f10x_usart.c ****   }
 379:stm32lib/src/stm32f10x_usart.c ****   else if (usartreg == 0x02) /* The IT is in CR2 register */
 193              		.loc 1 379 0
 194 0082 BCF1020F 		cmp	ip, #2
 195 0086 01D1     		bne	.L15
 380:stm32lib/src/stm32f10x_usart.c ****   {
 381:stm32lib/src/stm32f10x_usart.c ****     usartxbase += 0x10;
 196              		.loc 1 381 0
 197 0088 1030     		adds	r0, r0, #16
 198              	.LVL13:
 199 008a 00E0     		b	.L14
 200              	.LVL14:
 201              	.L15:
 382:stm32lib/src/stm32f10x_usart.c ****   }
 383:stm32lib/src/stm32f10x_usart.c ****   else /* The IT is in CR3 register */
 384:stm32lib/src/stm32f10x_usart.c ****   {
 385:stm32lib/src/stm32f10x_usart.c ****     usartxbase += 0x14; 
 202              		.loc 1 385 0
 203 008c 1430     		adds	r0, r0, #20
 204              	.LVL15:
 205              	.L14:
 386:stm32lib/src/stm32f10x_usart.c ****   }
 387:stm32lib/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 206              		.loc 1 387 0
 207 008e 12B1     		cbz	r2, .L16
 388:stm32lib/src/stm32f10x_usart.c ****   {
 389:stm32lib/src/stm32f10x_usart.c ****     *(vu32*)usartxbase  |= itmask;
 208              		.loc 1 389 0
 209 0090 0368     		ldr	r3, [r0, #0]
 210 0092 0B43     		orrs	r3, r3, r1
 211 0094 02E0     		b	.L19
 212              	.L16:
 390:stm32lib/src/stm32f10x_usart.c ****   }
 391:stm32lib/src/stm32f10x_usart.c ****   else
 392:stm32lib/src/stm32f10x_usart.c ****   {
 393:stm32lib/src/stm32f10x_usart.c ****     *(vu32*)usartxbase &= ~itmask;
 213              		.loc 1 393 0
 214 0096 0368     		ldr	r3, [r0, #0]
 215 0098 23EA0103 		bic	r3, r3, r1
 216              	.L19:
 217 009c 0360     		str	r3, [r0, #0]
 394:stm32lib/src/stm32f10x_usart.c ****   }
 395:stm32lib/src/stm32f10x_usart.c **** }
 218              		.loc 1 395 0
 219 009e 02B0     		add	sp, sp, #8
 220 00a0 7047     		bx	lr
 221              	.LFE29:
 223 00a2 00BF     		.align	2
 224              		.global	USART_DMACmd
 225              		.thumb
 226              		.thumb_func
 228              	USART_DMACmd:
 229              	.LFB30:
 396:stm32lib/src/stm32f10x_usart.c **** 
 397:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 398:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_DMACmd
 399:stm32lib/src/stm32f10x_usart.c **** * Description    : Enables or disables the USART’s DMA interface.
 400:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 401:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 402:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3 or UART4.
 403:stm32lib/src/stm32f10x_usart.c **** *                    Note: The DMA mode is not available for UART5.
 404:stm32lib/src/stm32f10x_usart.c **** *                  - USART_DMAReq: specifies the DMA request.
 405:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be any combination of the following values:
 406:stm32lib/src/stm32f10x_usart.c **** *                       - USART_DMAReq_Tx: USART DMA transmit request
 407:stm32lib/src/stm32f10x_usart.c **** *                       - USART_DMAReq_Rx: USART DMA receive request
 408:stm32lib/src/stm32f10x_usart.c **** *                  - NewState: new state of the DMA Request sources.
 409:stm32lib/src/stm32f10x_usart.c **** *                   This parameter can be: ENABLE or DISABLE.
 410:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 411:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 412:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 413:stm32lib/src/stm32f10x_usart.c **** void USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState)
 414:stm32lib/src/stm32f10x_usart.c **** {
 230              		.loc 1 414 0
 231              		@ args = 0, pretend = 0, frame = 0
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              		@ link register save eliminated.
 234              	.LVL16:
 415:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 416:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_1234_PERIPH(USARTx));
 417:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_DMAREQ(USART_DMAReq));  
 418:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 419:stm32lib/src/stm32f10x_usart.c **** 
 420:stm32lib/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 235              		.loc 1 420 0
 236 00a4 22B1     		cbz	r2, .L21
 421:stm32lib/src/stm32f10x_usart.c ****   {
 422:stm32lib/src/stm32f10x_usart.c ****     /* Enable the DMA transfer for selected requests by setting the DMAT and/or
 423:stm32lib/src/stm32f10x_usart.c ****        DMAR bits in the USART CR3 register */
 424:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR3 |= USART_DMAReq;
 237              		.loc 1 424 0
 238 00a6 838A     		ldrh	r3, [r0, #20]
 239 00a8 9BB2     		uxth	r3, r3
 240 00aa 41EA0303 		orr	r3, r1, r3
 241 00ae 03E0     		b	.L24
 242              	.L21:
 425:stm32lib/src/stm32f10x_usart.c ****   }
 426:stm32lib/src/stm32f10x_usart.c ****   else
 427:stm32lib/src/stm32f10x_usart.c ****   {
 428:stm32lib/src/stm32f10x_usart.c ****     /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
 429:stm32lib/src/stm32f10x_usart.c ****        DMAR bits in the USART CR3 register */
 430:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR3 &= (u16)~USART_DMAReq;
 243              		.loc 1 430 0
 244 00b0 838A     		ldrh	r3, [r0, #20]
 245 00b2 9BB2     		uxth	r3, r3
 246 00b4 23EA0103 		bic	r3, r3, r1
 247              	.L24:
 248 00b8 8382     		strh	r3, [r0, #20]	@ movhi
 431:stm32lib/src/stm32f10x_usart.c ****   }
 432:stm32lib/src/stm32f10x_usart.c **** }
 249              		.loc 1 432 0
 250 00ba 7047     		bx	lr
 251              	.LFE30:
 253              		.align	2
 254              		.global	USART_SetAddress
 255              		.thumb
 256              		.thumb_func
 258              	USART_SetAddress:
 259              	.LFB31:
 433:stm32lib/src/stm32f10x_usart.c **** 
 434:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 435:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_SetAddress
 436:stm32lib/src/stm32f10x_usart.c **** * Description    : Sets the address of the USART node.
 437:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 438:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 439:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 440:stm32lib/src/stm32f10x_usart.c **** *                  - USART_Address: Indicates the address of the USART node.
 441:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 442:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 443:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 444:stm32lib/src/stm32f10x_usart.c **** void USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address)
 445:stm32lib/src/stm32f10x_usart.c **** {
 260              		.loc 1 445 0
 261              		@ args = 0, pretend = 0, frame = 0
 262              		@ frame_needed = 0, uses_anonymous_args = 0
 263              		@ link register save eliminated.
 264              	.LVL17:
 446:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 447:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 448:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ADDRESS(USART_Address)); 
 449:stm32lib/src/stm32f10x_usart.c ****     
 450:stm32lib/src/stm32f10x_usart.c ****   /* Clear the USART address */
 451:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR2 &= CR2_Address_Mask;
 265              		.loc 1 451 0
 266 00bc 038A     		ldrh	r3, [r0, #16]
 267 00be 23F00F03 		bic	r3, r3, #15
 268 00c2 1B04     		lsls	r3, r3, #16
 269 00c4 1B0C     		lsrs	r3, r3, #16
 270 00c6 0382     		strh	r3, [r0, #16]	@ movhi
 452:stm32lib/src/stm32f10x_usart.c ****   /* Set the USART address node */
 453:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR2 |= USART_Address;
 271              		.loc 1 453 0
 272 00c8 038A     		ldrh	r3, [r0, #16]
 273 00ca 9BB2     		uxth	r3, r3
 274 00cc 0B43     		orrs	r3, r3, r1
 275 00ce 0382     		strh	r3, [r0, #16]	@ movhi
 454:stm32lib/src/stm32f10x_usart.c **** }
 276              		.loc 1 454 0
 277 00d0 7047     		bx	lr
 278              	.LFE31:
 280 00d2 00BF     		.align	2
 281              		.global	USART_WakeUpConfig
 282              		.thumb
 283              		.thumb_func
 285              	USART_WakeUpConfig:
 286              	.LFB32:
 455:stm32lib/src/stm32f10x_usart.c **** 
 456:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 457:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_WakeUpConfig
 458:stm32lib/src/stm32f10x_usart.c **** * Description    : Selects the USART WakeUp method.
 459:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 460:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 461:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 462:stm32lib/src/stm32f10x_usart.c **** *                  - USART_WakeUp: specifies the USART wakeup method.
 463:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 464:stm32lib/src/stm32f10x_usart.c **** *                        - USART_WakeUp_IdleLine: WakeUp by an idle line detection
 465:stm32lib/src/stm32f10x_usart.c **** *                        - USART_WakeUp_AddressMark: WakeUp by an address mark
 466:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 467:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 468:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 469:stm32lib/src/stm32f10x_usart.c **** void USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp)
 470:stm32lib/src/stm32f10x_usart.c **** {
 287              		.loc 1 470 0
 288              		@ args = 0, pretend = 0, frame = 0
 289              		@ frame_needed = 0, uses_anonymous_args = 0
 290              		@ link register save eliminated.
 291              	.LVL18:
 471:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 472:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 473:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_WAKEUP(USART_WakeUp));
 474:stm32lib/src/stm32f10x_usart.c ****   
 475:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR1 &= CR1_WAKE_Mask;
 292              		.loc 1 475 0
 293 00d4 8389     		ldrh	r3, [r0, #12]
 294 00d6 23F40063 		bic	r3, r3, #2048
 295 00da 1B04     		lsls	r3, r3, #16
 296 00dc 1B0C     		lsrs	r3, r3, #16
 297 00de 8381     		strh	r3, [r0, #12]	@ movhi
 476:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR1 |= USART_WakeUp;
 298              		.loc 1 476 0
 299 00e0 8389     		ldrh	r3, [r0, #12]
 300 00e2 9BB2     		uxth	r3, r3
 301 00e4 1943     		orrs	r1, r1, r3
 302              	.LVL19:
 303 00e6 8181     		strh	r1, [r0, #12]	@ movhi
 477:stm32lib/src/stm32f10x_usart.c **** }
 304              		.loc 1 477 0
 305 00e8 7047     		bx	lr
 306              	.LFE32:
 308 00ea 00BF     		.align	2
 309              		.global	USART_ReceiverWakeUpCmd
 310              		.thumb
 311              		.thumb_func
 313              	USART_ReceiverWakeUpCmd:
 314              	.LFB33:
 478:stm32lib/src/stm32f10x_usart.c **** 
 479:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 480:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_ReceiverWakeUpCmd
 481:stm32lib/src/stm32f10x_usart.c **** * Description    : Determines if the USART is in mute mode or not.
 482:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 483:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 484:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 485:stm32lib/src/stm32f10x_usart.c **** *                  - NewState: new state of the USART mute mode.
 486:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be: ENABLE or DISABLE.
 487:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 488:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 489:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 490:stm32lib/src/stm32f10x_usart.c **** void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 491:stm32lib/src/stm32f10x_usart.c **** {
 315              		.loc 1 491 0
 316              		@ args = 0, pretend = 0, frame = 0
 317              		@ frame_needed = 0, uses_anonymous_args = 0
 318              		@ link register save eliminated.
 319              	.LVL20:
 492:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 493:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 494:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState)); 
 495:stm32lib/src/stm32f10x_usart.c ****   
 496:stm32lib/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 320              		.loc 1 496 0
 321 00ec 21B1     		cbz	r1, .L30
 497:stm32lib/src/stm32f10x_usart.c ****   {
 498:stm32lib/src/stm32f10x_usart.c ****     /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
 499:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR1 |= CR1_RWU_Set;
 322              		.loc 1 499 0
 323 00ee 8389     		ldrh	r3, [r0, #12]
 324 00f0 9BB2     		uxth	r3, r3
 325 00f2 43F00203 		orr	r3, r3, #2
 326 00f6 04E0     		b	.L33
 327              	.L30:
 500:stm32lib/src/stm32f10x_usart.c ****   }
 501:stm32lib/src/stm32f10x_usart.c ****   else
 502:stm32lib/src/stm32f10x_usart.c ****   {
 503:stm32lib/src/stm32f10x_usart.c ****     /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
 504:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR1 &= CR1_RWU_Reset;
 328              		.loc 1 504 0
 329 00f8 8389     		ldrh	r3, [r0, #12]
 330 00fa 23F00203 		bic	r3, r3, #2
 331 00fe 1B04     		lsls	r3, r3, #16
 332 0100 1B0C     		lsrs	r3, r3, #16
 333              	.L33:
 334 0102 8381     		strh	r3, [r0, #12]	@ movhi
 505:stm32lib/src/stm32f10x_usart.c ****   }
 506:stm32lib/src/stm32f10x_usart.c **** }
 335              		.loc 1 506 0
 336 0104 7047     		bx	lr
 337              	.LFE33:
 339 0106 00BF     		.align	2
 340              		.global	USART_LINBreakDetectLengthConfig
 341              		.thumb
 342              		.thumb_func
 344              	USART_LINBreakDetectLengthConfig:
 345              	.LFB34:
 507:stm32lib/src/stm32f10x_usart.c **** 
 508:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 509:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_LINBreakDetectLengthConfig
 510:stm32lib/src/stm32f10x_usart.c **** * Description    : Sets the USART LIN Break detection length.
 511:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 512:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 513:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 514:stm32lib/src/stm32f10x_usart.c **** *                  - USART_LINBreakDetectLength: specifies the LIN break
 515:stm32lib/src/stm32f10x_usart.c **** *                    detection length.
 516:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 517:stm32lib/src/stm32f10x_usart.c **** *                       - USART_LINBreakDetectLength_10b: 10-bit break detection
 518:stm32lib/src/stm32f10x_usart.c **** *                       - USART_LINBreakDetectLength_11b: 11-bit break detection
 519:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 520:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 521:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 522:stm32lib/src/stm32f10x_usart.c **** void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength)
 523:stm32lib/src/stm32f10x_usart.c **** {
 346              		.loc 1 523 0
 347              		@ args = 0, pretend = 0, frame = 0
 348              		@ frame_needed = 0, uses_anonymous_args = 0
 349              		@ link register save eliminated.
 350              	.LVL21:
 524:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 525:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 526:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
 527:stm32lib/src/stm32f10x_usart.c ****   
 528:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR2 &= CR2_LBDL_Mask;
 351              		.loc 1 528 0
 352 0108 038A     		ldrh	r3, [r0, #16]
 353 010a 23F02003 		bic	r3, r3, #32
 354 010e 1B04     		lsls	r3, r3, #16
 355 0110 1B0C     		lsrs	r3, r3, #16
 356 0112 0382     		strh	r3, [r0, #16]	@ movhi
 529:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR2 |= USART_LINBreakDetectLength;  
 357              		.loc 1 529 0
 358 0114 038A     		ldrh	r3, [r0, #16]
 359 0116 9BB2     		uxth	r3, r3
 360 0118 1943     		orrs	r1, r1, r3
 361              	.LVL22:
 362 011a 0182     		strh	r1, [r0, #16]	@ movhi
 530:stm32lib/src/stm32f10x_usart.c **** }
 363              		.loc 1 530 0
 364 011c 7047     		bx	lr
 365              	.LFE34:
 367 011e 00BF     		.align	2
 368              		.global	USART_LINCmd
 369              		.thumb
 370              		.thumb_func
 372              	USART_LINCmd:
 373              	.LFB35:
 531:stm32lib/src/stm32f10x_usart.c **** 
 532:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 533:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_LINCmd
 534:stm32lib/src/stm32f10x_usart.c **** * Description    : Enables or disables the USART’s LIN mode.
 535:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 536:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 537:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 538:stm32lib/src/stm32f10x_usart.c **** *                  - NewState: new state of the USART LIN mode.
 539:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be: ENABLE or DISABLE.
 540:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 541:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 542:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 543:stm32lib/src/stm32f10x_usart.c **** void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 544:stm32lib/src/stm32f10x_usart.c **** {
 374              		.loc 1 544 0
 375              		@ args = 0, pretend = 0, frame = 0
 376              		@ frame_needed = 0, uses_anonymous_args = 0
 377              		@ link register save eliminated.
 378              	.LVL23:
 545:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 546:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 547:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 548:stm32lib/src/stm32f10x_usart.c ****   
 549:stm32lib/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 379              		.loc 1 549 0
 380 0120 21B1     		cbz	r1, .L37
 550:stm32lib/src/stm32f10x_usart.c ****   {
 551:stm32lib/src/stm32f10x_usart.c ****     /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
 552:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR2 |= CR2_LINEN_Set;
 381              		.loc 1 552 0
 382 0122 038A     		ldrh	r3, [r0, #16]
 383 0124 9BB2     		uxth	r3, r3
 384 0126 43F48043 		orr	r3, r3, #16384
 385 012a 04E0     		b	.L40
 386              	.L37:
 553:stm32lib/src/stm32f10x_usart.c ****   }
 554:stm32lib/src/stm32f10x_usart.c ****   else
 555:stm32lib/src/stm32f10x_usart.c ****   {
 556:stm32lib/src/stm32f10x_usart.c ****     /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
 557:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR2 &= CR2_LINEN_Reset;
 387              		.loc 1 557 0
 388 012c 038A     		ldrh	r3, [r0, #16]
 389 012e 23F48043 		bic	r3, r3, #16384
 390 0132 1B04     		lsls	r3, r3, #16
 391 0134 1B0C     		lsrs	r3, r3, #16
 392              	.L40:
 393 0136 0382     		strh	r3, [r0, #16]	@ movhi
 558:stm32lib/src/stm32f10x_usart.c ****   }
 559:stm32lib/src/stm32f10x_usart.c **** }
 394              		.loc 1 559 0
 395 0138 7047     		bx	lr
 396              	.LFE35:
 398 013a 00BF     		.align	2
 399              		.global	USART_SendData
 400              		.thumb
 401              		.thumb_func
 403              	USART_SendData:
 404              	.LFB36:
 560:stm32lib/src/stm32f10x_usart.c **** 
 561:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 562:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_SendData
 563:stm32lib/src/stm32f10x_usart.c **** * Description    : Transmits single data through the USARTx peripheral.
 564:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 565:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 566:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 567:stm32lib/src/stm32f10x_usart.c **** *                  - Data: the data to transmit.
 568:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 569:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 570:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 571:stm32lib/src/stm32f10x_usart.c **** void USART_SendData(USART_TypeDef* USARTx, u16 Data)
 572:stm32lib/src/stm32f10x_usart.c **** {
 405              		.loc 1 572 0
 406              		@ args = 0, pretend = 0, frame = 0
 407              		@ frame_needed = 0, uses_anonymous_args = 0
 408              		@ link register save eliminated.
 409              	.LVL24:
 573:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 574:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 575:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_DATA(Data)); 
 576:stm32lib/src/stm32f10x_usart.c ****     
 577:stm32lib/src/stm32f10x_usart.c ****   /* Transmit Data */
 578:stm32lib/src/stm32f10x_usart.c ****   USARTx->DR = (Data & (u16)0x01FF);
 410              		.loc 1 578 0
 411 013c C905     		lsls	r1, r1, #23
 412              	.LVL25:
 413 013e C90D     		lsrs	r1, r1, #23
 414 0140 8180     		strh	r1, [r0, #4]	@ movhi
 579:stm32lib/src/stm32f10x_usart.c **** }
 415              		.loc 1 579 0
 416 0142 7047     		bx	lr
 417              	.LFE36:
 419              		.align	2
 420              		.global	USART_ReceiveData
 421              		.thumb
 422              		.thumb_func
 424              	USART_ReceiveData:
 425              	.LFB37:
 580:stm32lib/src/stm32f10x_usart.c **** 
 581:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 582:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_ReceiveData
 583:stm32lib/src/stm32f10x_usart.c **** * Description    : Returns the most recent received data by the USARTx peripheral.
 584:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 585:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 586:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 587:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 588:stm32lib/src/stm32f10x_usart.c **** * Return         : The received data.
 589:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 590:stm32lib/src/stm32f10x_usart.c **** u16 USART_ReceiveData(USART_TypeDef* USARTx)
 591:stm32lib/src/stm32f10x_usart.c **** {
 426              		.loc 1 591 0
 427              		@ args = 0, pretend = 0, frame = 0
 428              		@ frame_needed = 0, uses_anonymous_args = 0
 429              		@ link register save eliminated.
 430              	.LVL26:
 592:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 593:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 594:stm32lib/src/stm32f10x_usart.c ****   
 595:stm32lib/src/stm32f10x_usart.c ****   /* Receive Data */
 596:stm32lib/src/stm32f10x_usart.c ****   return (u16)(USARTx->DR & (u16)0x01FF);
 431              		.loc 1 596 0
 432 0144 8088     		ldrh	r0, [r0, #4]
 433              	.LVL27:
 597:stm32lib/src/stm32f10x_usart.c **** }
 434              		.loc 1 597 0
 435 0146 C005     		lsls	r0, r0, #23
 436 0148 C00D     		lsrs	r0, r0, #23
 437 014a 7047     		bx	lr
 438              	.LFE37:
 440              		.align	2
 441              		.global	USART_SendBreak
 442              		.thumb
 443              		.thumb_func
 445              	USART_SendBreak:
 446              	.LFB38:
 598:stm32lib/src/stm32f10x_usart.c **** 
 599:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 600:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_SendBreak
 601:stm32lib/src/stm32f10x_usart.c **** * Description    : Transmits break characters.
 602:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 603:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 604:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 605:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 606:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 607:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 608:stm32lib/src/stm32f10x_usart.c **** void USART_SendBreak(USART_TypeDef* USARTx)
 609:stm32lib/src/stm32f10x_usart.c **** {
 447              		.loc 1 609 0
 448              		@ args = 0, pretend = 0, frame = 0
 449              		@ frame_needed = 0, uses_anonymous_args = 0
 450              		@ link register save eliminated.
 451              	.LVL28:
 610:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 611:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 612:stm32lib/src/stm32f10x_usart.c ****   
 613:stm32lib/src/stm32f10x_usart.c ****   /* Send break characters */
 614:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR1 |= CR1_SBK_Set;
 452              		.loc 1 614 0
 453 014c 8389     		ldrh	r3, [r0, #12]
 454 014e 9BB2     		uxth	r3, r3
 455 0150 43F00103 		orr	r3, r3, #1
 456 0154 8381     		strh	r3, [r0, #12]	@ movhi
 615:stm32lib/src/stm32f10x_usart.c **** }
 457              		.loc 1 615 0
 458 0156 7047     		bx	lr
 459              	.LFE38:
 461              		.align	2
 462              		.global	USART_SetGuardTime
 463              		.thumb
 464              		.thumb_func
 466              	USART_SetGuardTime:
 467              	.LFB39:
 616:stm32lib/src/stm32f10x_usart.c **** 
 617:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 618:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_SetGuardTime
 619:stm32lib/src/stm32f10x_usart.c **** * Description    : Sets the specified USART guard time.
 620:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
 621:stm32lib/src/stm32f10x_usart.c **** *                    peripheral.
 622:stm32lib/src/stm32f10x_usart.c **** *                  Note: The guard time bits are not available for UART4 and UART5.
 623:stm32lib/src/stm32f10x_usart.c **** *                  - USART_GuardTime: specifies the guard time.
 624:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 625:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 626:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 627:stm32lib/src/stm32f10x_usart.c **** void USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime)
 628:stm32lib/src/stm32f10x_usart.c **** {    
 468              		.loc 1 628 0
 469              		@ args = 0, pretend = 0, frame = 0
 470              		@ frame_needed = 0, uses_anonymous_args = 0
 471              		@ link register save eliminated.
 472              	.LVL29:
 629:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 630:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 631:stm32lib/src/stm32f10x_usart.c ****   
 632:stm32lib/src/stm32f10x_usart.c ****   /* Clear the USART Guard time */
 633:stm32lib/src/stm32f10x_usart.c ****   USARTx->GTPR &= GTPR_LSB_Mask;
 473              		.loc 1 633 0
 474 0158 038B     		ldrh	r3, [r0, #24]
 475 015a DBB2     		uxtb	r3, r3
 476 015c 0383     		strh	r3, [r0, #24]	@ movhi
 634:stm32lib/src/stm32f10x_usart.c ****   /* Set the USART guard time */
 635:stm32lib/src/stm32f10x_usart.c ****   USARTx->GTPR |= (u16)((u16)USART_GuardTime << 0x08);
 477              		.loc 1 635 0
 478 015e 038B     		ldrh	r3, [r0, #24]
 479 0160 9BB2     		uxth	r3, r3
 480 0162 43EA0123 		orr	r3, r3, r1, lsl #8
 481 0166 0383     		strh	r3, [r0, #24]	@ movhi
 636:stm32lib/src/stm32f10x_usart.c **** }
 482              		.loc 1 636 0
 483 0168 7047     		bx	lr
 484              	.LFE39:
 486 016a 00BF     		.align	2
 487              		.global	USART_SetPrescaler
 488              		.thumb
 489              		.thumb_func
 491              	USART_SetPrescaler:
 492              	.LFB40:
 637:stm32lib/src/stm32f10x_usart.c **** 
 638:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 639:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_SetPrescaler
 640:stm32lib/src/stm32f10x_usart.c **** * Description    : Sets the system clock prescaler.
 641:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 642:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 643:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 644:stm32lib/src/stm32f10x_usart.c **** *                  Note: The function is used for IrDA mode with UART4 and UART5.
 645:stm32lib/src/stm32f10x_usart.c **** *                  - USART_Prescaler: specifies the prescaler clock.
 646:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 647:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 648:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 649:stm32lib/src/stm32f10x_usart.c **** void USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler)
 650:stm32lib/src/stm32f10x_usart.c **** { 
 493              		.loc 1 650 0
 494              		@ args = 0, pretend = 0, frame = 0
 495              		@ frame_needed = 0, uses_anonymous_args = 0
 496              		@ link register save eliminated.
 497              	.LVL30:
 651:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 652:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 653:stm32lib/src/stm32f10x_usart.c ****   
 654:stm32lib/src/stm32f10x_usart.c ****   /* Clear the USART prescaler */
 655:stm32lib/src/stm32f10x_usart.c ****   USARTx->GTPR &= GTPR_MSB_Mask;
 498              		.loc 1 655 0
 499 016c 038B     		ldrh	r3, [r0, #24]
 500 016e 03F47F43 		and	r3, r3, #65280
 501 0172 0383     		strh	r3, [r0, #24]	@ movhi
 656:stm32lib/src/stm32f10x_usart.c ****   /* Set the USART prescaler */
 657:stm32lib/src/stm32f10x_usart.c ****   USARTx->GTPR |= USART_Prescaler;
 502              		.loc 1 657 0
 503 0174 038B     		ldrh	r3, [r0, #24]
 504 0176 9BB2     		uxth	r3, r3
 505 0178 0B43     		orrs	r3, r3, r1
 506 017a 0383     		strh	r3, [r0, #24]	@ movhi
 658:stm32lib/src/stm32f10x_usart.c **** }
 507              		.loc 1 658 0
 508 017c 7047     		bx	lr
 509              	.LFE40:
 511 017e 00BF     		.align	2
 512              		.global	USART_SmartCardCmd
 513              		.thumb
 514              		.thumb_func
 516              	USART_SmartCardCmd:
 517              	.LFB41:
 659:stm32lib/src/stm32f10x_usart.c **** 
 660:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 661:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_SmartCardCmd
 662:stm32lib/src/stm32f10x_usart.c **** * Description    : Enables or disables the USART’s Smart Card mode.
 663:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
 664:stm32lib/src/stm32f10x_usart.c **** *                    peripheral. 
 665:stm32lib/src/stm32f10x_usart.c **** *                    Note: The Smart Card mode is not available for UART4 and UART5.
 666:stm32lib/src/stm32f10x_usart.c **** *                  - NewState: new state of the Smart Card mode.
 667:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be: ENABLE or DISABLE.
 668:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 669:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 670:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 671:stm32lib/src/stm32f10x_usart.c **** void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 672:stm32lib/src/stm32f10x_usart.c **** {
 518              		.loc 1 672 0
 519              		@ args = 0, pretend = 0, frame = 0
 520              		@ frame_needed = 0, uses_anonymous_args = 0
 521              		@ link register save eliminated.
 522              	.LVL31:
 673:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 674:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));
 675:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 676:stm32lib/src/stm32f10x_usart.c **** 
 677:stm32lib/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 523              		.loc 1 677 0
 524 0180 21B1     		cbz	r1, .L52
 678:stm32lib/src/stm32f10x_usart.c ****   {
 679:stm32lib/src/stm32f10x_usart.c ****     /* Enable the SC mode by setting the SCEN bit in the CR3 register */
 680:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_SCEN_Set;
 525              		.loc 1 680 0
 526 0182 838A     		ldrh	r3, [r0, #20]
 527 0184 9BB2     		uxth	r3, r3
 528 0186 43F02003 		orr	r3, r3, #32
 529 018a 04E0     		b	.L55
 530              	.L52:
 681:stm32lib/src/stm32f10x_usart.c ****   }
 682:stm32lib/src/stm32f10x_usart.c ****   else
 683:stm32lib/src/stm32f10x_usart.c ****   {
 684:stm32lib/src/stm32f10x_usart.c ****     /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
 685:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_SCEN_Reset;
 531              		.loc 1 685 0
 532 018c 838A     		ldrh	r3, [r0, #20]
 533 018e 23F02003 		bic	r3, r3, #32
 534 0192 1B04     		lsls	r3, r3, #16
 535 0194 1B0C     		lsrs	r3, r3, #16
 536              	.L55:
 537 0196 8382     		strh	r3, [r0, #20]	@ movhi
 686:stm32lib/src/stm32f10x_usart.c ****   }
 687:stm32lib/src/stm32f10x_usart.c **** }
 538              		.loc 1 687 0
 539 0198 7047     		bx	lr
 540              	.LFE41:
 542 019a 00BF     		.align	2
 543              		.global	USART_SmartCardNACKCmd
 544              		.thumb
 545              		.thumb_func
 547              	USART_SmartCardNACKCmd:
 548              	.LFB42:
 688:stm32lib/src/stm32f10x_usart.c **** 
 689:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 690:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_SmartCardNACKCmd
 691:stm32lib/src/stm32f10x_usart.c **** * Description    : Enables or disables NACK transmission.
 692:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: where x can be 1, 2 or 3 to select the USART
 693:stm32lib/src/stm32f10x_usart.c **** *                    peripheral. 
 694:stm32lib/src/stm32f10x_usart.c **** *                    Note: The Smart Card mode is not available for UART4 and UART5.
 695:stm32lib/src/stm32f10x_usart.c **** *                  - NewState: new state of the NACK transmission.
 696:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be: ENABLE or DISABLE.
 697:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 698:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 699:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 700:stm32lib/src/stm32f10x_usart.c **** void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 701:stm32lib/src/stm32f10x_usart.c **** {
 549              		.loc 1 701 0
 550              		@ args = 0, pretend = 0, frame = 0
 551              		@ frame_needed = 0, uses_anonymous_args = 0
 552              		@ link register save eliminated.
 553              	.LVL32:
 702:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 703:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_123_PERIPH(USARTx));  
 704:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 705:stm32lib/src/stm32f10x_usart.c **** 
 706:stm32lib/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 554              		.loc 1 706 0
 555 019c 21B1     		cbz	r1, .L57
 707:stm32lib/src/stm32f10x_usart.c ****   {
 708:stm32lib/src/stm32f10x_usart.c ****     /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
 709:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_NACK_Set;
 556              		.loc 1 709 0
 557 019e 838A     		ldrh	r3, [r0, #20]
 558 01a0 9BB2     		uxth	r3, r3
 559 01a2 43F01003 		orr	r3, r3, #16
 560 01a6 04E0     		b	.L60
 561              	.L57:
 710:stm32lib/src/stm32f10x_usart.c ****   }
 711:stm32lib/src/stm32f10x_usart.c ****   else
 712:stm32lib/src/stm32f10x_usart.c ****   {
 713:stm32lib/src/stm32f10x_usart.c ****     /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
 714:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_NACK_Reset;
 562              		.loc 1 714 0
 563 01a8 838A     		ldrh	r3, [r0, #20]
 564 01aa 23F01003 		bic	r3, r3, #16
 565 01ae 1B04     		lsls	r3, r3, #16
 566 01b0 1B0C     		lsrs	r3, r3, #16
 567              	.L60:
 568 01b2 8382     		strh	r3, [r0, #20]	@ movhi
 715:stm32lib/src/stm32f10x_usart.c ****   }
 716:stm32lib/src/stm32f10x_usart.c **** }
 569              		.loc 1 716 0
 570 01b4 7047     		bx	lr
 571              	.LFE42:
 573 01b6 00BF     		.align	2
 574              		.global	USART_HalfDuplexCmd
 575              		.thumb
 576              		.thumb_func
 578              	USART_HalfDuplexCmd:
 579              	.LFB43:
 717:stm32lib/src/stm32f10x_usart.c **** 
 718:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 719:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_HalfDuplexCmd
 720:stm32lib/src/stm32f10x_usart.c **** * Description    : Enables or disables the USART’s Half Duplex communication.
 721:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 722:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 723:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 724:stm32lib/src/stm32f10x_usart.c **** *                  - NewState: new state of the USART Communication.
 725:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be: ENABLE or DISABLE.
 726:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 727:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 728:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 729:stm32lib/src/stm32f10x_usart.c **** void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
 730:stm32lib/src/stm32f10x_usart.c **** {
 580              		.loc 1 730 0
 581              		@ args = 0, pretend = 0, frame = 0
 582              		@ frame_needed = 0, uses_anonymous_args = 0
 583              		@ link register save eliminated.
 584              	.LVL33:
 731:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 732:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 733:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 734:stm32lib/src/stm32f10x_usart.c ****   
 735:stm32lib/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 585              		.loc 1 735 0
 586 01b8 21B1     		cbz	r1, .L62
 736:stm32lib/src/stm32f10x_usart.c ****   {
 737:stm32lib/src/stm32f10x_usart.c ****     /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
 738:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_HDSEL_Set;
 587              		.loc 1 738 0
 588 01ba 838A     		ldrh	r3, [r0, #20]
 589 01bc 9BB2     		uxth	r3, r3
 590 01be 43F00803 		orr	r3, r3, #8
 591 01c2 04E0     		b	.L65
 592              	.L62:
 739:stm32lib/src/stm32f10x_usart.c ****   }
 740:stm32lib/src/stm32f10x_usart.c ****   else
 741:stm32lib/src/stm32f10x_usart.c ****   {
 742:stm32lib/src/stm32f10x_usart.c ****     /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
 743:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_HDSEL_Reset;
 593              		.loc 1 743 0
 594 01c4 838A     		ldrh	r3, [r0, #20]
 595 01c6 23F00803 		bic	r3, r3, #8
 596 01ca 1B04     		lsls	r3, r3, #16
 597 01cc 1B0C     		lsrs	r3, r3, #16
 598              	.L65:
 599 01ce 8382     		strh	r3, [r0, #20]	@ movhi
 744:stm32lib/src/stm32f10x_usart.c ****   }
 745:stm32lib/src/stm32f10x_usart.c **** }
 600              		.loc 1 745 0
 601 01d0 7047     		bx	lr
 602              	.LFE43:
 604 01d2 00BF     		.align	2
 605              		.global	USART_IrDAConfig
 606              		.thumb
 607              		.thumb_func
 609              	USART_IrDAConfig:
 610              	.LFB44:
 746:stm32lib/src/stm32f10x_usart.c **** 
 747:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 748:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_IrDAConfig
 749:stm32lib/src/stm32f10x_usart.c **** * Description    : Configures the USART’s IrDA interface.
 750:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 751:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 752:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 753:stm32lib/src/stm32f10x_usart.c **** *                  - USART_IrDAMode: specifies the IrDA mode.
 754:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 755:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IrDAMode_LowPower
 756:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IrDAMode_Normal
 757:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 758:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 759:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 760:stm32lib/src/stm32f10x_usart.c **** void USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode)
 761:stm32lib/src/stm32f10x_usart.c **** {
 611              		.loc 1 761 0
 612              		@ args = 0, pretend = 0, frame = 0
 613              		@ frame_needed = 0, uses_anonymous_args = 0
 614              		@ link register save eliminated.
 615              	.LVL34:
 762:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 763:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 764:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
 765:stm32lib/src/stm32f10x_usart.c ****     
 766:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR3 &= CR3_IRLP_Mask;
 616              		.loc 1 766 0
 617 01d4 838A     		ldrh	r3, [r0, #20]
 618 01d6 23F00403 		bic	r3, r3, #4
 619 01da 1B04     		lsls	r3, r3, #16
 620 01dc 1B0C     		lsrs	r3, r3, #16
 621 01de 8382     		strh	r3, [r0, #20]	@ movhi
 767:stm32lib/src/stm32f10x_usart.c ****   USARTx->CR3 |= USART_IrDAMode;
 622              		.loc 1 767 0
 623 01e0 838A     		ldrh	r3, [r0, #20]
 624 01e2 9BB2     		uxth	r3, r3
 625 01e4 1943     		orrs	r1, r1, r3
 626              	.LVL35:
 627 01e6 8182     		strh	r1, [r0, #20]	@ movhi
 768:stm32lib/src/stm32f10x_usart.c **** }
 628              		.loc 1 768 0
 629 01e8 7047     		bx	lr
 630              	.LFE44:
 632 01ea 00BF     		.align	2
 633              		.global	USART_IrDACmd
 634              		.thumb
 635              		.thumb_func
 637              	USART_IrDACmd:
 638              	.LFB45:
 769:stm32lib/src/stm32f10x_usart.c **** 
 770:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 771:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_IrDACmd
 772:stm32lib/src/stm32f10x_usart.c **** * Description    : Enables or disables the USART’s IrDA interface.
 773:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 774:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 775:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 776:stm32lib/src/stm32f10x_usart.c **** *                  - NewState: new state of the IrDA mode.
 777:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be: ENABLE or DISABLE.
 778:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 779:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 780:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 781:stm32lib/src/stm32f10x_usart.c **** void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
 782:stm32lib/src/stm32f10x_usart.c **** {
 639              		.loc 1 782 0
 640              		@ args = 0, pretend = 0, frame = 0
 641              		@ frame_needed = 0, uses_anonymous_args = 0
 642              		@ link register save eliminated.
 643              	.LVL36:
 783:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 784:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 785:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 786:stm32lib/src/stm32f10x_usart.c ****     
 787:stm32lib/src/stm32f10x_usart.c ****   if (NewState != DISABLE)
 644              		.loc 1 787 0
 645 01ec 21B1     		cbz	r1, .L69
 788:stm32lib/src/stm32f10x_usart.c ****   {
 789:stm32lib/src/stm32f10x_usart.c ****     /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
 790:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR3 |= CR3_IREN_Set;
 646              		.loc 1 790 0
 647 01ee 838A     		ldrh	r3, [r0, #20]
 648 01f0 9BB2     		uxth	r3, r3
 649 01f2 43F00203 		orr	r3, r3, #2
 650 01f6 04E0     		b	.L72
 651              	.L69:
 791:stm32lib/src/stm32f10x_usart.c ****   }
 792:stm32lib/src/stm32f10x_usart.c ****   else
 793:stm32lib/src/stm32f10x_usart.c ****   {
 794:stm32lib/src/stm32f10x_usart.c ****     /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
 795:stm32lib/src/stm32f10x_usart.c ****     USARTx->CR3 &= CR3_IREN_Reset;
 652              		.loc 1 795 0
 653 01f8 838A     		ldrh	r3, [r0, #20]
 654 01fa 23F00203 		bic	r3, r3, #2
 655 01fe 1B04     		lsls	r3, r3, #16
 656 0200 1B0C     		lsrs	r3, r3, #16
 657              	.L72:
 658 0202 8382     		strh	r3, [r0, #20]	@ movhi
 796:stm32lib/src/stm32f10x_usart.c ****   }
 797:stm32lib/src/stm32f10x_usart.c **** }
 659              		.loc 1 797 0
 660 0204 7047     		bx	lr
 661              	.LFE45:
 663 0206 00BF     		.align	2
 664              		.global	USART_GetFlagStatus
 665              		.thumb
 666              		.thumb_func
 668              	USART_GetFlagStatus:
 669              	.LFB46:
 798:stm32lib/src/stm32f10x_usart.c **** 
 799:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 800:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_GetFlagStatus
 801:stm32lib/src/stm32f10x_usart.c **** * Description    : Checks whether the specified USART flag is set or not.
 802:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 803:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 804:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 805:stm32lib/src/stm32f10x_usart.c **** *                  - USART_FLAG: specifies the flag to check.
 806:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 807:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_CTS:  CTS Change flag (not available for 
 808:stm32lib/src/stm32f10x_usart.c **** *                                          UART4 and UART5)
 809:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_LBD:  LIN Break detection flag
 810:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_TXE:  Transmit data register empty flag
 811:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_TC:   Transmission Complete flag
 812:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_RXNE: Receive data register not empty flag
 813:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_IDLE: Idle Line detection flag
 814:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_ORE:  OverRun Error flag
 815:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_NE:   Noise Error flag
 816:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_FE:   Framing Error flag
 817:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_PE:   Parity Error flag
 818:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 819:stm32lib/src/stm32f10x_usart.c **** * Return         : The new state of USART_FLAG (SET or RESET).
 820:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 821:stm32lib/src/stm32f10x_usart.c **** FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG)
 822:stm32lib/src/stm32f10x_usart.c **** {
 670              		.loc 1 822 0
 671              		@ args = 0, pretend = 0, frame = 0
 672              		@ frame_needed = 0, uses_anonymous_args = 0
 673              		@ link register save eliminated.
 674              	.LVL37:
 823:stm32lib/src/stm32f10x_usart.c ****   FlagStatus bitstatus = RESET;
 824:stm32lib/src/stm32f10x_usart.c **** 
 825:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 826:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 827:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_FLAG(USART_FLAG));
 828:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART
 829:stm32lib/src/stm32f10x_usart.c **** 
 830:stm32lib/src/stm32f10x_usart.c ****   if ((USARTx->SR & USART_FLAG) != (u16)RESET)
 675              		.loc 1 830 0
 676 0208 0388     		ldrh	r3, [r0, #0]
 677 020a 1942     		tst	r1, r3
 831:stm32lib/src/stm32f10x_usart.c ****   {
 832:stm32lib/src/stm32f10x_usart.c ****     bitstatus = SET;
 833:stm32lib/src/stm32f10x_usart.c ****   }
 834:stm32lib/src/stm32f10x_usart.c ****   else
 835:stm32lib/src/stm32f10x_usart.c ****   {
 836:stm32lib/src/stm32f10x_usart.c ****     bitstatus = RESET;
 837:stm32lib/src/stm32f10x_usart.c ****   }
 838:stm32lib/src/stm32f10x_usart.c ****   return bitstatus;
 839:stm32lib/src/stm32f10x_usart.c **** }
 678              		.loc 1 839 0
 679 020c 0CBF     		ite	eq
 680 020e 0020     		moveq	r0, #0
 681 0210 0120     		movne	r0, #1
 682              	.LVL38:
 683 0212 7047     		bx	lr
 684              	.LFE46:
 686              		.align	2
 687              		.global	USART_ClearFlag
 688              		.thumb
 689              		.thumb_func
 691              	USART_ClearFlag:
 692              	.LFB47:
 840:stm32lib/src/stm32f10x_usart.c **** 
 841:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 842:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_ClearFlag
 843:stm32lib/src/stm32f10x_usart.c **** * Description    : Clears the USARTx's pending flags.
 844:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 845:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 846:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 847:stm32lib/src/stm32f10x_usart.c **** *                  - USART_FLAG: specifies the flag to clear.
 848:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be any combination of the following values:
 849:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_CTS:  CTS Change flag (not available for
 850:stm32lib/src/stm32f10x_usart.c **** *                                          UART4 and UART5).
 851:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_LBD:  LIN Break detection flag.
 852:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_TC:   Transmission Complete flag.
 853:stm32lib/src/stm32f10x_usart.c **** *                       - USART_FLAG_RXNE: Receive data register not empty flag.
 854:stm32lib/src/stm32f10x_usart.c **** *
 855:stm32lib/src/stm32f10x_usart.c **** *                  Notes:
 856:stm32lib/src/stm32f10x_usart.c **** *                        - PE (Parity error), FE (Framing error), NE (Noise error),
 857:stm32lib/src/stm32f10x_usart.c **** *                          ORE (OverRun error) and IDLE (Idle line detected) 
 858:stm32lib/src/stm32f10x_usart.c **** *                          flags are cleared by software sequence: a read 
 859:stm32lib/src/stm32f10x_usart.c **** *                          operation to USART_SR register (USART_GetFlagStatus()) 
 860:stm32lib/src/stm32f10x_usart.c **** *                          followed by a read operation to USART_DR register 
 861:stm32lib/src/stm32f10x_usart.c **** *                          (USART_ReceiveData()).
 862:stm32lib/src/stm32f10x_usart.c **** *                        - RXNE flag can be also cleared by a read to the 
 863:stm32lib/src/stm32f10x_usart.c **** *                          USART_DR register (USART_ReceiveData()).
 864:stm32lib/src/stm32f10x_usart.c **** *                        - TC flag can be also cleared by software sequence: a 
 865:stm32lib/src/stm32f10x_usart.c **** *                          read operation to USART_SR register 
 866:stm32lib/src/stm32f10x_usart.c **** *                          (USART_GetFlagStatus()) followed by a write operation
 867:stm32lib/src/stm32f10x_usart.c **** *                          to USART_DR register (USART_SendData()).                                
 868:stm32lib/src/stm32f10x_usart.c **** *                        - TXE flag is cleared only by a write to the USART_DR 
 869:stm32lib/src/stm32f10x_usart.c **** *                          register (USART_SendData()).                        
 870:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 871:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 872:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 873:stm32lib/src/stm32f10x_usart.c **** void USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG)
 874:stm32lib/src/stm32f10x_usart.c **** {
 693              		.loc 1 874 0
 694              		@ args = 0, pretend = 0, frame = 0
 695              		@ frame_needed = 0, uses_anonymous_args = 0
 696              		@ link register save eliminated.
 697              	.LVL39:
 875:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 876:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 877:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
 878:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_PERIPH_FLAG(USARTx, USART_FLAG)); /* The CTS flag is not available for UART
 879:stm32lib/src/stm32f10x_usart.c ****    
 880:stm32lib/src/stm32f10x_usart.c ****   USARTx->SR = (u16)~USART_FLAG;
 698              		.loc 1 880 0
 699 0214 C943     		mvns	r1, r1
 700              	.LVL40:
 701 0216 89B2     		uxth	r1, r1
 702 0218 0180     		strh	r1, [r0, #0]	@ movhi
 881:stm32lib/src/stm32f10x_usart.c **** }
 703              		.loc 1 881 0
 704 021a 7047     		bx	lr
 705              	.LFE47:
 707              		.align	2
 708              		.global	USART_GetITStatus
 709              		.thumb
 710              		.thumb_func
 712              	USART_GetITStatus:
 713              	.LFB48:
 882:stm32lib/src/stm32f10x_usart.c **** 
 883:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 884:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_GetITStatus
 885:stm32lib/src/stm32f10x_usart.c **** * Description    : Checks whether the specified USART interrupt has occurred or not.
 886:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 887:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 888:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 889:stm32lib/src/stm32f10x_usart.c **** *                  - USART_IT: specifies the USART interrupt source to check.
 890:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 891:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_CTS:  CTS change interrupt (not available for 
 892:stm32lib/src/stm32f10x_usart.c **** *                                        UART4 and UART5)
 893:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_LBD:  LIN Break detection interrupt
 894:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_TXE:  Tansmit Data Register empty interrupt
 895:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_TC:   Transmission complete interrupt
 896:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_RXNE: Receive Data register not empty 
 897:stm32lib/src/stm32f10x_usart.c **** *                                        interrupt
 898:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_IDLE: Idle line detection interrupt
 899:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_ORE:  OverRun Error interrupt
 900:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_NE:   Noise Error interrupt
 901:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_FE:   Framing Error interrupt
 902:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_PE:   Parity Error interrupt
 903:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 904:stm32lib/src/stm32f10x_usart.c **** * Return         : The new state of USART_IT (SET or RESET).
 905:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 906:stm32lib/src/stm32f10x_usart.c **** ITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT)
 907:stm32lib/src/stm32f10x_usart.c **** {
 714              		.loc 1 907 0
 715              		@ args = 0, pretend = 0, frame = 0
 716              		@ frame_needed = 0, uses_anonymous_args = 0
 717              	.LVL41:
 908:stm32lib/src/stm32f10x_usart.c ****   u32 bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
 909:stm32lib/src/stm32f10x_usart.c ****   ITStatus bitstatus = RESET;
 910:stm32lib/src/stm32f10x_usart.c **** 
 911:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 912:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 913:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_GET_IT(USART_IT));
 914:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UAR
 915:stm32lib/src/stm32f10x_usart.c ****   
 916:stm32lib/src/stm32f10x_usart.c ****   /* Get the USART register index */
 917:stm32lib/src/stm32f10x_usart.c ****   usartreg = (((u8)USART_IT) >> 0x05);
 918:stm32lib/src/stm32f10x_usart.c **** 
 919:stm32lib/src/stm32f10x_usart.c ****   /* Get the interrupt position */
 920:stm32lib/src/stm32f10x_usart.c ****   itmask = USART_IT & IT_Mask;
 921:stm32lib/src/stm32f10x_usart.c **** 
 922:stm32lib/src/stm32f10x_usart.c ****   itmask = (u32)0x01 << itmask;
 718              		.loc 1 922 0
 719 021c 0123     		movs	r3, #1
 720              		.loc 1 907 0
 721 021e 10B5     		push	{r4, lr}
 722              	.LCFI2:
 723              		.loc 1 922 0
 724 0220 01F01F02 		and	r2, r1, #31
 725              		.loc 1 907 0
 726 0224 0446     		mov	r4, r0
 727              		.loc 1 917 0
 728 0226 C1F34210 		ubfx	r0, r1, #5, #3
 729              	.LVL42:
 730              		.loc 1 922 0
 731 022a 13FA02F2 		lsls	r2, r3, r2
 732              	.LVL43:
 923:stm32lib/src/stm32f10x_usart.c ****   
 924:stm32lib/src/stm32f10x_usart.c ****   if (usartreg == 0x01) /* The IT  is in CR1 register */
 733              		.loc 1 924 0
 734 022e 9842     		cmp	r0, r3
 735 0230 01D1     		bne	.L78
 925:stm32lib/src/stm32f10x_usart.c ****   {
 926:stm32lib/src/stm32f10x_usart.c ****     itmask &= USARTx->CR1;
 736              		.loc 1 926 0
 737 0232 A389     		ldrh	r3, [r4, #12]
 738 0234 03E0     		b	.L84
 739              	.L78:
 927:stm32lib/src/stm32f10x_usart.c ****   }
 928:stm32lib/src/stm32f10x_usart.c ****   else if (usartreg == 0x02) /* The IT  is in CR2 register */
 740              		.loc 1 928 0
 741 0236 0228     		cmp	r0, #2
 929:stm32lib/src/stm32f10x_usart.c ****   {
 930:stm32lib/src/stm32f10x_usart.c ****     itmask &= USARTx->CR2;
 742              		.loc 1 930 0
 743 0238 0CBF     		ite	eq
 744 023a 238A     		ldrheq	r3, [r4, #16]
 931:stm32lib/src/stm32f10x_usart.c ****   }
 932:stm32lib/src/stm32f10x_usart.c ****   else /* The IT  is in CR3 register */
 933:stm32lib/src/stm32f10x_usart.c ****   {
 934:stm32lib/src/stm32f10x_usart.c ****     itmask &= USARTx->CR3;
 745              		.loc 1 934 0
 746 023c A38A     		ldrhne	r3, [r4, #20]
 747              	.L84:
 748 023e 9BB2     		uxth	r3, r3
 749 0240 02EA0300 		and	r0, r2, r3
 750              	.LVL44:
 935:stm32lib/src/stm32f10x_usart.c ****   }
 936:stm32lib/src/stm32f10x_usart.c ****   
 937:stm32lib/src/stm32f10x_usart.c ****   bitpos = USART_IT >> 0x08;
 938:stm32lib/src/stm32f10x_usart.c **** 
 939:stm32lib/src/stm32f10x_usart.c ****   bitpos = (u32)0x01 << bitpos;
 940:stm32lib/src/stm32f10x_usart.c ****   bitpos &= USARTx->SR;
 751              		.loc 1 940 0
 752 0244 2388     		ldrh	r3, [r4, #0]
 753 0246 9CB2     		uxth	r4, r3
 754              	.LVL45:
 941:stm32lib/src/stm32f10x_usart.c **** 
 942:stm32lib/src/stm32f10x_usart.c ****   if ((itmask != (u16)RESET)&&(bitpos != (u16)RESET))
 755              		.loc 1 942 0
 756 0248 30B1     		cbz	r0, .L82
 757              		.loc 1 939 0
 758 024a 0A0A     		lsrs	r2, r1, #8
 759 024c 0123     		movs	r3, #1
 760 024e 9340     		lsls	r3, r3, r2
 761              	.LVL46:
 762 0250 2342     		tst	r3, r4
 763 0252 0CBF     		ite	eq
 764 0254 0020     		moveq	r0, #0
 765 0256 0120     		movne	r0, #1
 766              	.LVL47:
 767              	.L82:
 768              	.LVL48:
 943:stm32lib/src/stm32f10x_usart.c ****   {
 944:stm32lib/src/stm32f10x_usart.c ****     bitstatus = SET;
 945:stm32lib/src/stm32f10x_usart.c ****   }
 946:stm32lib/src/stm32f10x_usart.c ****   else
 947:stm32lib/src/stm32f10x_usart.c ****   {
 948:stm32lib/src/stm32f10x_usart.c ****     bitstatus = RESET;
 949:stm32lib/src/stm32f10x_usart.c ****   }
 950:stm32lib/src/stm32f10x_usart.c ****   
 951:stm32lib/src/stm32f10x_usart.c ****   return bitstatus;  
 952:stm32lib/src/stm32f10x_usart.c **** }
 769              		.loc 1 952 0
 770 0258 10BD     		pop	{r4, pc}
 771              	.LFE48:
 773 025a 00BF     		.align	2
 774              		.global	USART_ClearITPendingBit
 775              		.thumb
 776              		.thumb_func
 778              	USART_ClearITPendingBit:
 779              	.LFB49:
 953:stm32lib/src/stm32f10x_usart.c **** 
 954:stm32lib/src/stm32f10x_usart.c **** /*******************************************************************************
 955:stm32lib/src/stm32f10x_usart.c **** * Function Name  : USART_ClearITPendingBit
 956:stm32lib/src/stm32f10x_usart.c **** * Description    : Clears the USARTx’s interrupt pending bits.
 957:stm32lib/src/stm32f10x_usart.c **** * Input          : - USARTx: Select the USART or the UART peripheral. 
 958:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 959:stm32lib/src/stm32f10x_usart.c **** *                     - USART1, USART2, USART3, UART4 or UART5.
 960:stm32lib/src/stm32f10x_usart.c **** *                  - USART_IT: specifies the interrupt pending bit to clear.
 961:stm32lib/src/stm32f10x_usart.c **** *                    This parameter can be one of the following values:
 962:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_CTS:  CTS change interrupt (not available for 
 963:stm32lib/src/stm32f10x_usart.c **** *                                        UART4 and UART5)
 964:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_LBD:  LIN Break detection interrupt
 965:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_TC:   Transmission complete interrupt. 
 966:stm32lib/src/stm32f10x_usart.c **** *                       - USART_IT_RXNE: Receive Data register not empty interrupt.
 967:stm32lib/src/stm32f10x_usart.c **** *                    
 968:stm32lib/src/stm32f10x_usart.c **** *                  Notes:
 969:stm32lib/src/stm32f10x_usart.c **** *                        - PE (Parity error), FE (Framing error), NE (Noise error),
 970:stm32lib/src/stm32f10x_usart.c **** *                          ORE (OverRun error) and IDLE (Idle line detected) 
 971:stm32lib/src/stm32f10x_usart.c **** *                          pending bits are cleared by software sequence: a read 
 972:stm32lib/src/stm32f10x_usart.c **** *                          operation to USART_SR register (USART_GetITStatus()) 
 973:stm32lib/src/stm32f10x_usart.c **** *                          followed by a read operation to USART_DR register 
 974:stm32lib/src/stm32f10x_usart.c **** *                          (USART_ReceiveData()).
 975:stm32lib/src/stm32f10x_usart.c **** *                        - RXNE pending bit can be also cleared by a read to the 
 976:stm32lib/src/stm32f10x_usart.c **** *                          USART_DR register (USART_ReceiveData()).
 977:stm32lib/src/stm32f10x_usart.c **** *                        - TC pending bit can be also cleared by software 
 978:stm32lib/src/stm32f10x_usart.c **** *                          sequence: a read operation to USART_SR register 
 979:stm32lib/src/stm32f10x_usart.c **** *                          (USART_GetITStatus()) followed by a write operation
 980:stm32lib/src/stm32f10x_usart.c **** *                          to USART_DR register (USART_SendData()).                                
 981:stm32lib/src/stm32f10x_usart.c **** *                        - TXE pending bit is cleared only by a write to the 
 982:stm32lib/src/stm32f10x_usart.c **** *                          USART_DR register (USART_SendData()).  
 983:stm32lib/src/stm32f10x_usart.c **** * Output         : None
 984:stm32lib/src/stm32f10x_usart.c **** * Return         : None
 985:stm32lib/src/stm32f10x_usart.c **** *******************************************************************************/
 986:stm32lib/src/stm32f10x_usart.c **** void USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT)
 987:stm32lib/src/stm32f10x_usart.c **** {
 780              		.loc 1 987 0
 781              		@ args = 0, pretend = 0, frame = 0
 782              		@ frame_needed = 0, uses_anonymous_args = 0
 783              		@ link register save eliminated.
 784              	.LVL49:
 988:stm32lib/src/stm32f10x_usart.c ****   u16 bitpos = 0x00, itmask = 0x00;
 989:stm32lib/src/stm32f10x_usart.c **** 
 990:stm32lib/src/stm32f10x_usart.c ****   /* Check the parameters */
 991:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_ALL_PERIPH(USARTx));
 992:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_CLEAR_IT(USART_IT));
 993:stm32lib/src/stm32f10x_usart.c ****   assert_param(IS_USART_PERIPH_IT(USARTx, USART_IT)); /* The CTS interrupt is not available for UAR
 994:stm32lib/src/stm32f10x_usart.c ****   
 995:stm32lib/src/stm32f10x_usart.c ****   bitpos = USART_IT >> 0x08;
 996:stm32lib/src/stm32f10x_usart.c **** 
 997:stm32lib/src/stm32f10x_usart.c ****   itmask = (u16)((u16)0x01 << bitpos);
 998:stm32lib/src/stm32f10x_usart.c ****   USARTx->SR = (u16)~itmask;
 785              		.loc 1 998 0
 786 025c 090A     		lsrs	r1, r1, #8
 787              	.LVL50:
 788 025e 0123     		movs	r3, #1
 789 0260 8B40     		lsls	r3, r3, r1
 790 0262 DB43     		mvns	r3, r3
 791 0264 9BB2     		uxth	r3, r3
 792 0266 0380     		strh	r3, [r0, #0]	@ movhi
 999:stm32lib/src/stm32f10x_usart.c **** }
 793              		.loc 1 999 0
 794 0268 7047     		bx	lr
 795              	.LFE49:
 797 026a 00BF     		.align	2
 798              		.global	USART_Init
 799              		.thumb
 800              		.thumb_func
 802              	USART_Init:
 803              	.LFB24:
 804              		.loc 1 141 0
 805              		@ args = 0, pretend = 0, frame = 32
 806              		@ frame_needed = 0, uses_anonymous_args = 0
 807              	.LVL51:
 808              		.loc 1 162 0
 809 026c 038A     		ldrh	r3, [r0, #16]
 810              	.LVL52:
 811              		.loc 1 171 0
 812 026e CA88     		ldrh	r2, [r1, #6]
 813              		.loc 1 164 0
 814 0270 23F44053 		bic	r3, r3, #12288
 815              	.LVL53:
 816 0274 1B04     		lsls	r3, r3, #16
 817 0276 1B0C     		lsrs	r3, r3, #16
 818              		.loc 1 171 0
 819 0278 1343     		orrs	r3, r3, r2
 820              	.LVL54:
 821 027a 0382     		strh	r3, [r0, #16]	@ movhi
 822              		.loc 1 174 0
 823 027c 8289     		ldrh	r2, [r0, #12]
 824              		.loc 1 186 0
 825 027e 0B89     		ldrh	r3, [r1, #8]
 826              		.loc 1 141 0
 827 0280 30B5     		push	{r4, r5, lr}
 828              	.LCFI3:
 829 0282 0D46     		mov	r5, r1
 830              		.loc 1 186 0
 831 0284 8988     		ldrh	r1, [r1, #4]
 832              	.LVL55:
 833              		.loc 1 176 0
 834 0286 22F4B052 		bic	r2, r2, #5632
 835              	.LVL56:
 836              		.loc 1 186 0
 837 028a 0B43     		orrs	r3, r3, r1
 838 028c 6989     		ldrh	r1, [r5, #10]
 839              		.loc 1 176 0
 840 028e 22F00C02 		bic	r2, r2, #12
 841              		.loc 1 186 0
 842 0292 0B43     		orrs	r3, r3, r1
 843              		.loc 1 176 0
 844 0294 1204     		lsls	r2, r2, #16
 845 0296 120C     		lsrs	r2, r2, #16
 846              		.loc 1 186 0
 847 0298 9BB2     		uxth	r3, r3
 848 029a 1343     		orrs	r3, r3, r2
 849 029c 8381     		strh	r3, [r0, #12]	@ movhi
 850              		.loc 1 189 0
 851 029e 838A     		ldrh	r3, [r0, #20]
 852              		.loc 1 198 0
 853 02a0 AA89     		ldrh	r2, [r5, #12]
 854              	.LVL57:
 855              		.loc 1 191 0
 856 02a2 23F44073 		bic	r3, r3, #768
 857              	.LVL58:
 858 02a6 1B04     		lsls	r3, r3, #16
 859 02a8 1B0C     		lsrs	r3, r3, #16
 860              		.loc 1 141 0
 861 02aa 89B0     		sub	sp, sp, #36
 862              	.LCFI4:
 863              		.loc 1 198 0
 864 02ac 1343     		orrs	r3, r3, r2
 865              	.LVL59:
 866              		.loc 1 162 0
 867 02ae 0446     		mov	r4, r0
 868              	.LVL60:
 869              		.loc 1 198 0
 870 02b0 8382     		strh	r3, [r0, #20]	@ movhi
 871              	.LVL61:
 872              		.loc 1 141 0
 873 02b2 0190     		str	r0, [sp, #4]
 874              	.LVL62:
 875              		.loc 1 202 0
 876 02b4 03A8     		add	r0, sp, #12
 877              	.LVL63:
 878 02b6 FFF7FEFF 		bl	RCC_GetClocksFreq
 879              		.loc 1 203 0
 880 02ba 0E4B     		ldr	r3, .L91
 881 02bc 9C42     		cmp	r4, r3
 882              		.loc 1 205 0
 883 02be 0CBF     		ite	eq
 884 02c0 069B     		ldreq	r3, [sp, #24]
 885              	.LVL64:
 886              		.loc 1 209 0
 887 02c2 059B     		ldrne	r3, [sp, #20]
 888              		.loc 1 213 0
 889 02c4 1922     		movs	r2, #25
 890 02c6 5A43     		muls	r2, r3, r2
 891 02c8 2B68     		ldr	r3, [r5, #0]
 892              	.LVL65:
 893              		.loc 1 214 0
 894 02ca 6420     		movs	r0, #100
 895              		.loc 1 213 0
 896 02cc 9B00     		lsls	r3, r3, #2
 897 02ce B2FBF3F2 		udiv	r2, r2, r3
 898              	.LVL66:
 899              		.loc 1 214 0
 900 02d2 B2FBF0F1 		udiv	r1, r2, r0
 901 02d6 0901     		lsls	r1, r1, #4
 902              	.LVL67:
 903              		.loc 1 218 0
 904 02d8 0B09     		lsrs	r3, r1, #4
 905 02da 00FB1323 		mls	r3, r0, r3, r2
 906 02de 1B01     		lsls	r3, r3, #4
 907 02e0 3233     		adds	r3, r3, #50
 908 02e2 B3FBF0F3 		udiv	r3, r3, r0
 909 02e6 03F00F03 		and	r3, r3, #15
 910              		.loc 1 221 0
 911 02ea 0B43     		orrs	r3, r3, r1
 912 02ec 9BB2     		uxth	r3, r3
 913 02ee 2381     		strh	r3, [r4, #8]	@ movhi
 914              		.loc 1 222 0
 915 02f0 09B0     		add	sp, sp, #36
 916 02f2 30BD     		pop	{r4, r5, pc}
 917              	.L92:
 918              		.align	2
 919              	.L91:
 920 02f4 00380140 		.word	1073821696
 921              	.LFE24:
 923              		.align	2
 924              		.global	USART_DeInit
 925              		.thumb
 926              		.thumb_func
 928              	USART_DeInit:
 929              	.LFB23:
 930              		.loc 1 91 0
 931              		@ args = 0, pretend = 0, frame = 8
 932              		@ frame_needed = 0, uses_anonymous_args = 0
 933              	.LVL68:
 934 02f8 07B5     		push	{r0, r1, r2, lr}
 935              	.LCFI5:
 936              	.LVL69:
 937              		.loc 1 95 0
 938 02fa 214B     		ldr	r3, .L104
 939              		.loc 1 91 0
 940 02fc 0190     		str	r0, [sp, #4]
 941              	.LVL70:
 942              		.loc 1 95 0
 943 02fe 9842     		cmp	r0, r3
 944              	.LVL71:
 945 0300 2BD0     		beq	.L97
 946 0302 08D8     		bhi	.L100
 947 0304 A3F50063 		sub	r3, r3, #2048
 948 0308 9842     		cmp	r0, r3
 949 030a 16D0     		beq	.L95
 950 030c 03F58063 		add	r3, r3, #1024
 951 0310 9842     		cmp	r0, r3
 952 0312 34D1     		bne	.L101
 953 0314 19E0     		b	.L103
 954              	.L100:
 955 0316 1B4B     		ldr	r3, .L104+4
 956 0318 9842     		cmp	r0, r3
 957 031a 26D0     		beq	.L98
 958 031c 03F56843 		add	r3, r3, #59392
 959 0320 9842     		cmp	r0, r3
 960 0322 2CD1     		bne	.L101
 961              		.loc 1 98 0
 962 0324 0121     		movs	r1, #1
 963 0326 4FF48040 		mov	r0, #16384
 964 032a FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 965              		.loc 1 99 0
 966 032e 4FF48040 		mov	r0, #16384
 967 0332 0021     		movs	r1, #0
 968 0334 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 969 0338 21E0     		b	.L101
 970              	.L95:
 971              		.loc 1 103 0
 972 033a 4FF40030 		mov	r0, #131072
 973 033e 0121     		movs	r1, #1
 974 0340 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 975              		.loc 1 104 0
 976 0344 4FF40030 		mov	r0, #131072
 977 0348 16E0     		b	.L102
 978              	.L103:
 979              		.loc 1 108 0
 980 034a 4FF48020 		mov	r0, #262144
 981 034e 0121     		movs	r1, #1
 982 0350 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 983              		.loc 1 109 0
 984 0354 4FF48020 		mov	r0, #262144
 985 0358 0EE0     		b	.L102
 986              	.L97:
 987              		.loc 1 113 0
 988 035a 4FF40020 		mov	r0, #524288
 989 035e 0121     		movs	r1, #1
 990 0360 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 991              		.loc 1 114 0
 992 0364 4FF40020 		mov	r0, #524288
 993 0368 06E0     		b	.L102
 994              	.L98:
 995              		.loc 1 118 0
 996 036a 4FF48010 		mov	r0, #1048576
 997 036e 0121     		movs	r1, #1
 998 0370 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 999              		.loc 1 119 0
 1000 0374 4FF48010 		mov	r0, #1048576
 1001              	.L102:
 1002 0378 0021     		movs	r1, #0
 1003 037a FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
 1004              	.L101:
 1005              		.loc 1 125 0
 1006 037e 0EBD     		pop	{r1, r2, r3, pc}
 1007              	.L105:
 1008              		.align	2
 1009              	.L104:
 1010 0380 004C0040 		.word	1073761280
 1011 0384 00500040 		.word	1073762304
 1012              	.LFE23:
 1292              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f10x_usart.c
     /tmp/ccXtCsdz.s:22     .text:00000000 $t
     /tmp/ccXtCsdz.s:27     .text:00000000 USART_StructInit
     /tmp/ccXtCsdz.s:60     .text:0000001c USART_ClockInit
     /tmp/ccXtCsdz.s:104    .text:00000040 USART_ClockStructInit
     /tmp/ccXtCsdz.s:129    .text:0000004c USART_Cmd
     /tmp/ccXtCsdz.s:160    .text:00000068 USART_ITConfig
     /tmp/ccXtCsdz.s:228    .text:000000a4 USART_DMACmd
     /tmp/ccXtCsdz.s:258    .text:000000bc USART_SetAddress
     /tmp/ccXtCsdz.s:285    .text:000000d4 USART_WakeUpConfig
     /tmp/ccXtCsdz.s:313    .text:000000ec USART_ReceiverWakeUpCmd
     /tmp/ccXtCsdz.s:344    .text:00000108 USART_LINBreakDetectLengthConfig
     /tmp/ccXtCsdz.s:372    .text:00000120 USART_LINCmd
     /tmp/ccXtCsdz.s:403    .text:0000013c USART_SendData
     /tmp/ccXtCsdz.s:424    .text:00000144 USART_ReceiveData
     /tmp/ccXtCsdz.s:445    .text:0000014c USART_SendBreak
     /tmp/ccXtCsdz.s:466    .text:00000158 USART_SetGuardTime
     /tmp/ccXtCsdz.s:491    .text:0000016c USART_SetPrescaler
     /tmp/ccXtCsdz.s:516    .text:00000180 USART_SmartCardCmd
     /tmp/ccXtCsdz.s:547    .text:0000019c USART_SmartCardNACKCmd
     /tmp/ccXtCsdz.s:578    .text:000001b8 USART_HalfDuplexCmd
     /tmp/ccXtCsdz.s:609    .text:000001d4 USART_IrDAConfig
     /tmp/ccXtCsdz.s:637    .text:000001ec USART_IrDACmd
     /tmp/ccXtCsdz.s:668    .text:00000208 USART_GetFlagStatus
     /tmp/ccXtCsdz.s:691    .text:00000214 USART_ClearFlag
     /tmp/ccXtCsdz.s:712    .text:0000021c USART_GetITStatus
     /tmp/ccXtCsdz.s:778    .text:0000025c USART_ClearITPendingBit
     /tmp/ccXtCsdz.s:802    .text:0000026c USART_Init
     /tmp/ccXtCsdz.s:920    .text:000002f4 $d
     /tmp/ccXtCsdz.s:923    .text:000002f8 $t
     /tmp/ccXtCsdz.s:928    .text:000002f8 USART_DeInit
     /tmp/ccXtCsdz.s:1010   .text:00000380 $d

UNDEFINED SYMBOLS
RCC_GetClocksFreq
RCC_APB2PeriphResetCmd
RCC_APB1PeriphResetCmd
